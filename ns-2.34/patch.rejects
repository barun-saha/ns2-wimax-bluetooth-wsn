--- allinone/install	2007-03-10 18:40:05.000000000 -0500
+++ allinone/install	2009-04-01 18:01:36.000000000 -0400
@@ -16,7 +16,7 @@
 # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 #
-# $Header: /cvsroot/nsnam/ns-2/allinone/install,v 1.31 2007/03/10 23:40:05 tom_henderson Exp $
+# $Header: /home/rouil/cvsroot/ns-2.34/allinone/install,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $
 
 die() {
 	echo "$@"  1>&2
--- classifier/classifier.cc	2005-09-26 05:12:46.000000000 -0400
+++ classifier/classifier.cc	2009-04-01 18:01:36.000000000 -0400
@@ -34,7 +34,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/classifier/classifier.cc,v 1.42 2005/09/26 09:12:46 lacage Exp $";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/classifier/classifier.cc,v 1.1.1.1 2008/04/11 18:40:31 rouil Exp $";
 #endif
 
 #include <stdlib.h>
--- common/packet.cc	2000-09-15 16:32:57.000000000 -0400
+++ common/packet.cc	2009-04-01 18:01:36.000000000 -0400
@@ -34,7 +34,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/common/packet.cc,v 1.18 2000/09/15 20:32:57 haoboy Exp $ (LBL)";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/common/packet.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $ (LBL)";
 #endif
 
 #include "packet.h"
--- common/packet.h	2006-02-22 08:32:23.000000000 -0500
+++ common/packet.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/common/packet.h,v 1.100 2006/02/22 13:32:23 mahrenho Exp $ (LBL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/common/packet.h,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $ (LBL)
  */
 
 #ifndef ns_packet_h
@@ -170,6 +170,9 @@
 	// Bell Labs Traffic Trace Type (PackMime OL)
 	PT_BLTRACE, 
 
+	//WiMAX
+	PT_WIMAXBS,
+
 	// insert new packet types here
 	PT_NTYPE // This MUST be the LAST one
 };
@@ -269,6 +272,9 @@
 		// Bell Labs (PackMime OL)
 		name_[PT_BLTRACE]="BellLabsTrace";
 		
+		// WiMAX
+		name_[PT_WIMAXBS]="wimaxCtrl";
+
 		name_[PT_NTYPE]= "undefined";
 	}
 	const char* name(packet_t p) const { 
--- common/scheduler.cc	2006-02-21 10:20:18.000000000 -0500
+++ common/scheduler.cc	2009-04-01 18:01:36.000000000 -0400
@@ -31,12 +31,12 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/common/scheduler.cc,v 1.74 2006/02/21 15:20:18 mahrenho Exp $
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/common/scheduler.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $
  */
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/common/scheduler.cc,v 1.74 2006/02/21 15:20:18 mahrenho Exp $ (LBL)";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/common/scheduler.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $ (LBL)";
 #endif
 
 #include <stdlib.h>
--- common/scheduler.h	2005-07-26 21:13:42.000000000 -0400
+++ common/scheduler.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/common/scheduler.h,v 1.27 2005/07/27 01:13:42 tomh Exp $ (LBL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/common/scheduler.h,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $ (LBL)
  */
 
 #ifndef ns_scheduler_h
--- conf/configure.in.head	2005-09-07 02:35:44.000000000 -0400
+++ conf/configure.in.head	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
 dnl standard setup for vic/vat/etc. autoconf scripts.
-dnl $Header: /cvsroot/nsnam/conf/configure.in.head,v 1.28 2005/09/07 06:35:44 tomh Exp $ (LBL)
+dnl $Header: /home/rouil/cvsroot/ns-2.34/conf/configure.in.head,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
 
 
 AC_ARG_WITH(defaultoptions, -with-defaultoptions[=filename]	use <filename> as default options file, , with_defaultoptions=".configure")
--- conf/configure.in.int64_t	1999-10-13 18:52:59.000000000 -0400
+++ conf/configure.in.int64_t	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
 dnl autoconf rules for 64-bit integers
-dnl $Id: configure.in.int64_t,v 1.6 1999/10/13 22:52:59 heideman Exp $
+dnl $Id: configure.in.int64_t,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $
 
 dnl
 dnl start by looking for supporting functions
--- conf/configure.in.tail	2005-07-21 00:06:12.000000000 -0400
+++ conf/configure.in.tail	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
 dnl standard final commands for vic/vat/etc. autoconf scripts
-dnl $Header: /cvsroot/nsnam/conf/configure.in.tail,v 1.25 2005/07/21 04:06:12 tomh Exp $ (LBL)
+dnl $Header: /home/rouil/cvsroot/ns-2.34/conf/configure.in.tail,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
 
 
 if test "$enable_static" = "yes" ; then
--- conf/configure.in.tcl	2007-02-18 17:42:36.000000000 -0500
+++ conf/configure.in.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
 dnl autoconf rules to find tcl
-dnl $Header: /cvsroot/nsnam/conf/configure.in.tcl,v 1.45 2007/02/18 22:42:36 tom_henderson Exp $ (LBL)
+dnl $Header: /home/rouil/cvsroot/ns-2.34/conf/configure.in.tcl,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
 
 AC_ARG_WITH(tcl,	--with-tcl=path	specify a pathname for tcl, d=$withval, d="")
 
--- conf/configure.in.tk	2007-02-18 17:42:36.000000000 -0500
+++ conf/configure.in.tk	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
 dnl autoconf rules to find tk 
-dnl $Header: /cvsroot/nsnam/conf/configure.in.tk,v 1.33 2007/02/18 22:42:36 tom_henderson Exp $ (LBL)
+dnl $Header: /home/rouil/cvsroot/ns-2.34/conf/configure.in.tk,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
 
 
 AC_ARG_WITH(tk,	--with-tk=path	specify a pathname for tk, d=$withval, d="")
--- conf/configure.in.x11	2004-12-17 10:14:20.000000000 -0500
+++ conf/configure.in.x11	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
 dnl autoconf rules to find X11 includes and libraries
-dnl $Header: /cvsroot/nsnam/conf/configure.in.x11,v 1.3 2004/12/17 15:14:20 ehlert Exp $ (LBL)
+dnl $Header: /home/rouil/cvsroot/ns-2.34/conf/configure.in.x11,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
 
 xlibdirs="\
 	/usr/openwin/lib \
--- diffusion3/filter_core/iolog.cc	2005-09-13 00:53:47.000000000 -0400
+++ diffusion3/filter_core/iolog.cc	2009-04-01 18:01:36.000000000 -0400
@@ -3,7 +3,7 @@
 // Authors       : Fabio Silva and Yutaka Mori
 //
 // Copyright (C) 2000-2002 by the University of Southern California
-// $Id: iolog.cc,v 1.3 2005/09/13 04:53:47 tomh Exp $
+// $Id: iolog.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU General Public License,
--- diffusion3/lib/main/events.cc	2005-09-13 00:53:49.000000000 -0400
+++ diffusion3/lib/main/events.cc	2009-04-01 18:01:36.000000000 -0400
@@ -3,7 +3,7 @@
 // authors       : Lewis Girod John Heidemann and Fabio Silva
 //
 // Copyright (C) 2000-2002 by the University of Southern California
-// $Id: events.cc,v 1.9 2005/09/13 04:53:49 tomh Exp $
+// $Id: events.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU General Public License,
--- diffusion3/lib/main/tools.cc	2005-10-05 11:16:02.000000000 -0400
+++ diffusion3/lib/main/tools.cc	2009-04-01 18:01:36.000000000 -0400
@@ -3,7 +3,7 @@
 // authors       : Fabio Silva
 //
 // Copyright (C) 2000-2002 by the University of Southern California
-// $Id: tools.cc,v 1.16 2005/10/05 15:16:02 sfloyd Exp $
+// $Id: tools.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU General Public License,
--- lib/bsd-list.h	2000-08-16 20:04:21.000000000 -0400
+++ lib/bsd-list.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * SUCH DAMAGE.
  *
  *	@(#)queue.h	8.5 (Berkeley) 8/20/94
- * $Id: bsd-list.h,v 1.1 2000/08/17 00:04:21 haoboy Exp $
+ * $Id: bsd-list.h,v 1.1.1.1 2008/04/11 18:40:20 rouil Exp $
  */
 
 #ifndef _NS_BSD_LIST_H_
--- mac/channel.cc	2005-02-03 15:15:00.000000000 -0500
+++ mac/channel.cc	2009-04-01 18:01:36.000000000 -0400
@@ -37,7 +37,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/mac/channel.cc,v 1.45 2005/02/03 20:15:00 haldar Exp $ (UCB)";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/mac/channel.cc,v 1.1.1.1 2008/04/11 18:40:20 rouil Exp $ (UCB)";
 #endif
 
 // Time interval for updating a position of a node in the X-List
--- mac/mac-802_11.cc	2006-01-30 16:27:51.000000000 -0500
+++ mac/mac-802_11.cc	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Header: /cvsroot/nsnam/ns-2/mac/mac-802_11.cc,v 1.51 2006/01/30 21:27:51 mweigle Exp $
+ * $Header: /home/rouil/cvsroot/ns-2.34/mac/mac-802_11.cc,v 1.1.1.1 2008/04/11 18:40:20 rouil Exp $
  *
  * Ported from CMU/Monarch's code, nov'98 -Padma.
  * Contributions by:
--- mac/mac-802_11.h	2006-02-22 08:25:43.000000000 -0500
+++ mac/mac-802_11.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Header: /cvsroot/nsnam/ns-2/mac/mac-802_11.h,v 1.27 2006/02/22 13:25:43 mahrenho Exp $
+ * $Header: /home/rouil/cvsroot/ns-2.34/mac/mac-802_11.h,v 1.1.1.1 2008/04/11 18:40:20 rouil Exp $
  *
  * Ported from CMU/Monarch's code, nov'98 -Padma.
  * wireless-mac-802_11.h
--- mac/mac.h	2005-07-26 21:13:44.000000000 -0400
+++ mac/mac.h	2009-04-01 18:01:36.000000000 -0400
@@ -33,7 +33,7 @@
  *
  * Contributed by Giao Nguyen, http://daedalus.cs.berkeley.edu/~gnguyen
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/mac/mac.h,v 1.36 2005/07/27 01:13:44 tomh Exp $ (UCB)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/mac/mac.h,v 1.1.1.1 2008/04/11 18:40:20 rouil Exp $ (UCB)
  */
 
 #ifndef ns_mac_h
--- mac/wireless-phy.cc	2007-01-30 00:00:50.000000000 -0500
+++ mac/wireless-phy.cc	2009-04-01 18:01:36.000000000 -0400
@@ -32,7 +32,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Header: /cvsroot/nsnam/ns-2/mac/wireless-phy.cc,v 1.27 2007/01/30 05:00:50 tom_henderson Exp $
+ * $Header: /home/rouil/cvsroot/ns-2.34/mac/wireless-phy.cc,v 1.2 2008/04/17 15:07:01 wimax Exp $
  *
  * Ported from CMU/Monarch's code, nov'98 -Padma Haldar.
  * wireless-phy.cc
@@ -53,16 +53,18 @@
 #include <agent.h>
 #include <trace.h>
 #include <sys/param.h>  /* for MIN/MAX */
-
 #include "diffusion/diff_header.h"
 
+#ifdef MAX
+#undef MAX
+#endif
 #define MAX(a,b) (((a)<(b))?(b):(a))
 
+
 void Sleep_Timer::expire(Event *) {
 	a_->UpdateSleepEnergy();
 }
 
-
 /* ======================================================================
    WirelessPhy Interface
    ====================================================================== */
--- Makefile.in	2007-03-10 18:49:57.000000000 -0500
+++ Makefile.in	2009-04-01 18:01:36.000000000 -0400
@@ -233,6 +234,7 @@
 	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
 	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
 	mobile/propagation.o mobile/tworayground.o \
+        mobile/prop_OFDMA.o mobile/cost231.o \
 	mobile/antenna.o mobile/omni-antenna.o \
 	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
 	common/bi-connector.o common/node.o \
@@ -309,6 +312,26 @@
 	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
 	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
 	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
+        wimax/ofdmphy.o wimax/mac802_16pkt.o \
+        wimax/scheduling/wimaxscheduler.o wimax/scheduling/bsscheduler.o \
+        wimax/scheduling/ssscheduler.o wimax/scheduling/ulsubframetimer.o \
+        wimax/scheduling/dlsubframetimer.o \
+        wimax/scheduling/burst.o wimax/scheduling/contentionslot.o \
+	wimax/arqstatus.o \
+        wimax/scheduling/contentionrequest.o wimax/scheduling/contentiontimer.o \
+        wimax/scheduling/dlburst.o wimax/scheduling/ulburst.o \
+        wimax/scheduling/framemap.o wimax/scheduling/phypdu.o \
+        wimax/scheduling/profile.o wimax/scheduling/subframe.o \
+        wimax/scheduling/scanningstation.o \
+        wimax/serviceflowqos.o wimax/serviceflow.o \
+        wimax/serviceflowhandler.o \
+        wimax/connection.o wimax/connectionmanager.o wimax/peernode.o \
+        wimax/mac802_16.o wimax/mac802_16BS.o wimax/mac802_16SS.o \
+        wimax/sduclassifier.o \
+        wimax/destclassifier.o wimax/mac802_16timer.o \
+        wimax/wimaxneighborentry.o wimax/neighbordb.o \
+        wimax/scheduling/wimaxctrlagent.o \
+        wimax/globalparams_wimax.o \
 	@V_STLOBJ@
 
 
--- mobile/shadowing.cc	2005-08-25 14:58:09.000000000 -0400
+++ mobile/shadowing.cc	2009-04-01 18:01:36.000000000 -0400
@@ -3,7 +3,7 @@
 /*
  * shadowing.cc
  * Copyright (C) 2000 by the University of Southern California
- * $Id: shadowing.cc,v 1.4 2005/08/25 18:58:09 johnh Exp $
+ * $Id: shadowing.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License,
--- queue/priqueue.cc	2004-10-07 13:56:03.000000000 -0400
+++ queue/priqueue.cc	2009-04-01 18:01:35.000000000 -0400
@@ -37,7 +37,7 @@
    priqueue.cc
    
    A simple priority queue with a remove packet function
-   $Id: priqueue.cc,v 1.7 2004/10/07 17:56:03 haldar Exp $
+   $Id: priqueue.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $
    */
 
 #include <object.h>
--- queue/red.cc	2006-12-17 10:21:59.000000000 -0500
+++ queue/red.cc	2009-04-01 18:01:35.000000000 -0400
@@ -57,7 +57,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-     "@(#) $Header: /cvsroot/nsnam/ns-2/queue/red.cc,v 1.83 2006/12/17 15:21:59 mweigle Exp $ (LBL)";
+     "@(#) $Header: /home/rouil/cvsroot/ns-2.34/queue/red.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)";
 #endif
 
 #include <math.h>
--- queue/red.h	2005-12-02 23:30:25.000000000 -0500
+++ queue/red.h	2009-04-01 18:01:35.000000000 -0400
@@ -53,7 +53,7 @@
  * "wait" indicates whether the gateway should wait between dropping
  *   packets.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/queue/red.h,v 1.44 2005/12/03 04:30:25 sallyfloyd Exp $ (LBL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/queue/red.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
  */
 
 #ifndef ns_red_h
--- queue/srr.cc	2003-01-06 19:06:17.000000000 -0500
+++ queue/srr.cc	2009-04-01 18:01:35.000000000 -0400
@@ -66,7 +66,7 @@
 #endif // DEBUG_SRR
 
 // this struct is the basic element for the Weight Matrix
-struct wm_node
+struct wm_node
 {
 	int queueid; // the queue the node belongs to 
 	int weight;  // the weight of the node
@@ -124,7 +124,7 @@
 	Packet *deque(void);
 	void enque(Packet *pkt);
 	void clear();
-
+
 public:
 	int maxqueuenumber_ ;	//total number of flows allowed
 	int blimit_;			//total number of bytes allowed across all flows
@@ -231,7 +231,7 @@
 
 	pwmCurr = 0; // at first, pwmCurr points to NULL
 
-	for(i=0; i<MAXFLOW; i++)
+	for(i=0; i<MAXFLOW; i++)
 	{
 		private_rate[i] = granularity_; //default quantum value for each flow
 		f2q[i]=0;		 // default queue id for all the flow
@@ -249,7 +249,7 @@
 		wmTail[i].next=NULL;
 		wmHead[i].queueid=wmTail[i].queueid=-1; // 
 		wmHead[i].weight=wmHead[i].weight=i;
-	}
+	}
 
 	for (i=0;i<MAXFLOW; i++)	
 		pRowHead[i]= pRowTail[i] = NULL;
@@ -284,7 +284,7 @@
 	flowid= iph->flowid(); 		//get the flowid
 	queueid= f2q[flowid]; 	// get the corresponding queue id
 
-	if(queueid > maxqueuenumber_)
+	if(queueid > maxqueuenumber_)
 	{
 		fprintf(stderr, "queueid too big\n");
 		exit(1);
@@ -331,7 +331,7 @@
 			add_to_WM(queueid, weight);
 			
 			q->deficitCounter=0;
-	}
+	}
 
 }
 
@@ -481,13 +481,13 @@
 
 	int old_colno = currMaxColumn;
 
-	if(weight==0)
+	if(weight==0)
 	{
 		fprintf(stderr, "add_to_WM: weight should not be zero");
 		exit(1);
 	}
 
-	if(weight > ( (1<<(maxColumn+1))-1) )
+	if(weight > ( (1<<(maxColumn+1))-1) )
 	{
 		fprintf(stderr, "add_to_WM: weight too big");
 		exit(1);
@@ -498,16 +498,16 @@
 	// if it is a first active flow, put the pwmPtr
 
 	
-	for(i=maxColumn; i>=0; i--)
+	for(i=maxColumn; i>=0; i--)
 	{
 
-		if (weight & (1<<i) )
-		{  
+		if (weight & (1<<i) )
+		{  
 			// 
 			// add to queueid= i; wmHead[queueid], wmTail[queueid]
-			pNode=(struct wm_node*)malloc(sizeof(struct wm_node));
+			pNode=(struct wm_node*)malloc(sizeof(struct wm_node));
 
-			if(pNode==NULL)
+			if(pNode==NULL)
 			{
 				fprintf(stderr, "no memeory to create WM node");
 				exit(2);
@@ -542,23 +542,23 @@
 			if(currMaxColumn < i)
 				currMaxColumn = i; // adjust the current max column number
 			
-			if(wmEmptyFlag == 1)
+			if(wmEmptyFlag == 1)
 			{
 				wmEmptyFlag=0;
-				if(pwmCurr == NULL) // we should let it points to the correct place.
+				if(pwmCurr == NULL) // we should let it points to the correct place.
 					pwmCurr=pNode;
 			}
 
 		}
-	}
+	}
 	
-	if (  old_colno < currMaxColumn )
+	if (  old_colno < currMaxColumn )
 	{
 		if(old_colno >= 0){
 	//	if(old_colno > 0){
-			int pc = wss.get_ptr () + 1;
-			pc = pc << (currMaxColumn - old_colno);
-			wss.set_ptr ( pc -1);
+			int pc = wss.get_ptr () + 1;
+			pc = pc << (currMaxColumn - old_colno);
+			wss.set_ptr ( pc -1);
 		//	printf("set_ptr in add_to_wm: ptr:%d\n", pc-1);
 		//	printf("old column no: %d %d\n", old_colno, currMaxColumn);
 		}
@@ -571,23 +571,23 @@
 
 
 //remove the wm_node from the links and free the memory
-int SRR::del_from_WM(int queueid, int weight)
+int SRR::del_from_WM(int queueid, int weight)
 {
 	struct wm_node *pNode, *pNode2;
-	int i;
-	int wss_term; 
-	int temp; 
+	int i;
+	int wss_term; 
+	int temp; 
 
 
-	if(pwmCurr->queueid==queueid)  // we adjust pwmCurr before we delete the row
+	if(pwmCurr->queueid==queueid)  // we adjust pwmCurr before we delete the row
 	{ 
-		if (pwmCurr->next != &wmTail[pwmCurr->weight])
-			pwmCurr = pwmCurr->next ;
+		if (pwmCurr->next != &wmTail[pwmCurr->weight])
+			pwmCurr = pwmCurr->next ;
 		else pwmCurr = NULL;
 	}
 
 	/*
-	for(i=0;i<=currMaxColumn;i++) // travel all double links, and delete the node whose id is queueid
+	for(i=0;i<=currMaxColumn;i++) // travel all double links, and delete the node whose id is queueid
 	{ 
 		pNode=wmHead[i].next;
 
@@ -620,20 +620,20 @@
 	pRowHead[queueid] = pRowTail[queueid] = NULL;
 
 // we should adjust currMaxColumn, 
-//and if currMaxColumn becomes less, we should also adjust WSS's pointer
-	
-	int old_colno = currMaxColumn;
+//and if currMaxColumn becomes less, we should also adjust WSS's pointer
+	
+	int old_colno = currMaxColumn;
 
-	for(i=currMaxColumn;i>=0;i--)
+	for(i=currMaxColumn;i>=0;i--)
 	{
-		if(wmHead[i].next != &wmTail[i])
+		if(wmHead[i].next != &wmTail[i])
 		{
 		  currMaxColumn=i;
 		  break;
 		}
 	}
 
-	if(i<0)
+	if(i<0)
 	{
 		// it is empty now.
 #ifdef DEBUG_SRR
@@ -642,41 +642,41 @@
 		wmEmptyFlag=1;
 		currMaxColumn=-1;
 		pwmCurr=NULL;
-		last_queueid=-1;
+		last_queueid=-1;
 		wss.set_ptr (0); // reset the WSS sequence pointer to 0;
 		goto rr;
-	} else if ( currMaxColumn < old_colno)
-	{
-		int pc = wss.get_ptr () +1;
+	} else if ( currMaxColumn < old_colno)
+	{
+		int pc = wss.get_ptr () +1;
 		//printf("pc = %d \n", pc);
-		int mul = 1 << (old_colno - currMaxColumn ); 
-		int tmpc = pc / mul;
-		if (pc % mul){
-			tmpc += 1;
-			if (tmpc > ((1<<(currMaxColumn+1) )- 1) )
-				tmpc = 1;
-
-		}
-		wss.set_ptr (tmpc -1);
+		int mul = 1 << (old_colno - currMaxColumn ); 
+		int tmpc = pc / mul;
+		if (pc % mul){
+			tmpc += 1;
+			if (tmpc > ((1<<(currMaxColumn+1) )- 1) )
+				tmpc = 1;
+
+		}
+		wss.set_ptr (tmpc -1);
 		//printf("set_ptr in del_from__wm: ptr:%d\n", tmpc-1);
 		//printf("k:%d j:%d\n", currMaxColumn, old_colno);
-
+
+	}
+	if (pwmCurr == NULL){
+loop:
+		wss_term=wss.get(currMaxColumn+1);
+		wss.inc_ptr (currMaxColumn+1 );
+		temp = currMaxColumn+1-wss_term;
+		 
+		// try to point pwmCurr to the right place.
+		if( wmHead[temp].next != &wmTail[temp])	
+		{
+			pwmCurr=wmHead[temp].next;	
+
+		}else
+			goto loop;
 	}
-	if (pwmCurr == NULL){
-loop:
-		wss_term=wss.get(currMaxColumn+1);
-		wss.inc_ptr (currMaxColumn+1 );
-		temp = currMaxColumn+1-wss_term;
-		 
-		// try to point pwmCurr to the right place.
-		if( wmHead[temp].next != &wmTail[temp])	
-		{
-			pwmCurr=wmHead[temp].next;	
-
-		}else
-			goto loop;
-	}
-
+
 rr:
 	--flwcnt;
 	return 0;
@@ -695,7 +695,7 @@
 
 
 	if(bytecnt==0){
-		//	printf("getNextNode, pwmCurr = NULL, wmEmptyFlag=%d\n", wmEmptyFlag);
+		//	printf("getNextNode, pwmCurr = NULL, wmEmptyFlag=%d\n", wmEmptyFlag);
 		return NULL;
 	}
 
@@ -710,12 +710,12 @@
 			exit(0);
 		}
 
-again:
-		wss_term=wss.get(currMaxColumn+1);
-		wss.inc_ptr (currMaxColumn+1 );
+again:
+		wss_term=wss.get(currMaxColumn+1);
+		wss.inc_ptr (currMaxColumn+1 );
 
 		temp = currMaxColumn+1-wss_term;
-		
+		
 		// wss_term according to currMaxColumn+1-wss_term queue
 	 	if( wmHead[temp].next != &wmTail[temp])	{
 			pwmCurr=wmHead[temp].next;	
--- queue/wss.h	2003-01-06 19:06:17.000000000 -0500
+++ queue/wss.h	2009-04-01 18:01:35.000000000 -0400
@@ -1,165 +1,165 @@
-/*
- * Copyright (c) 1991-1994 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and the Network Research Group at
- *	Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- */
-
-
-/* it is used to generate the Weight Spread Sequence of SRR 
- * WSS and SRR are named by Dr. W. Qi 
- */
-
-/*
-#include <stdio.h>
-#include <math.h>
-#include <string.h>
-#include <stdlib.h>
-*/
-
-class PacketSRR;
-class SRR;
-
-int power( int base, int j)
-{
-	int r=1; int i;
-	if(j==0) return 1;
-	else
-	{
-		for(i=0;i<j;i++)
-		r*=base;
-	}
-
-	return r;
-}
-
-void rawScan( int i, int j, int N, int *p)
-{
-	if(j==N)
-	{
-		*p=N;
-		return;
-	}
-
-	if(i%(int)power(2,j))
-	{
-		*p=j;
-		return;
-	}
-	else
-		rawScan(i, j+1, N, p);
-}
-
-class WSS{
-	public:WSS(): currOrder(1), items(0), ptr(0), pwss(0){ }
-	friend class SRR;
-public:	
-	int maxOrder; // the order of the WSS
-	int currOrder; // current order of WSS
-	int items; //how many items are in the WSS
-	unsigned int ptr;
-	int *pwss;  // 
-	void init(int i);
-
-	int get_ptr()
-	{
-	  return ptr;
-	}
-
-	void set_ptr (int val){
-		ptr = val;
-	}
-
-	void inc_ptr ( int order)
-	{
-		ptr += 1;
-		if((int)ptr > ((1<<order)-2))
-		{
-			ptr = 0;
-		}
-	}
-
-	int get(int order);
-
-	void print(); // for debug purpose
-
-};
-
-void WSS::init(int i){
-	int j;
-	maxOrder=i;
-	items= (1<<maxOrder)-1;
-	ptr=0;
-	pwss=(int*)malloc(sizeof(int)*items);
-	
-	for(j=1;j<=items; j++)
-		rawScan(j, 1, maxOrder,  (int*)(pwss+j-1));
-}
-
-int WSS::get(int order)  // it should also tells the WSS the order
-{  
-	int value;
-
-	currOrder=order;
-
-	//printf("get wss\n");
-	int tmp = 1 << order;
-	if((int)ptr > (tmp-2))
-	{
-		printf("tmp :%d \n", tmp);
-		printf("error, too large ptr:%d, order:%d\n", (int)ptr, order);
-		exit(0);
-	}
-
-	value= *(pwss+ptr);
-	return value;
-}
-
-void WSS::print(){
-	int i;
-	for(i=0;i<items;i++)
-		printf("%4d", *(pwss+i));
-	printf("\n");
-}
-
-/*
-main(int argc,  char **argv)
-{
-	WSS wss;
-	if(argc!=2)
-	{
-		printf("usage:%s number\n", argv[0]);
-		exit(0);
-	}
-	wss.init(atoi(argv[1]));
-	wss.print();
-}
-*/
+/*
+ * Copyright (c) 1991-1994 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and the Network Research Group at
+ *	Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+
+/* it is used to generate the Weight Spread Sequence of SRR 
+ * WSS and SRR are named by Dr. W. Qi 
+ */
+
+/*
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+*/
+
+class PacketSRR;
+class SRR;
+
+int power( int base, int j)
+{
+	int r=1; int i;
+	if(j==0) return 1;
+	else
+	{
+		for(i=0;i<j;i++)
+		r*=base;
+	}
+
+	return r;
+}
+
+void rawScan( int i, int j, int N, int *p)
+{
+	if(j==N)
+	{
+		*p=N;
+		return;
+	}
+
+	if(i%(int)power(2,j))
+	{
+		*p=j;
+		return;
+	}
+	else
+		rawScan(i, j+1, N, p);
+}
+
+class WSS{
+	public:WSS(): currOrder(1), items(0), ptr(0), pwss(0){ }
+	friend class SRR;
+public:	
+	int maxOrder; // the order of the WSS
+	int currOrder; // current order of WSS
+	int items; //how many items are in the WSS
+	unsigned int ptr;
+	int *pwss;  // 
+	void init(int i);
+
+	int get_ptr()
+	{
+	  return ptr;
+	}
+
+	void set_ptr (int val){
+		ptr = val;
+	}
+
+	void inc_ptr ( int order)
+	{
+		ptr += 1;
+		if((int)ptr > ((1<<order)-2))
+		{
+			ptr = 0;
+		}
+	}
+
+	int get(int order);
+
+	void print(); // for debug purpose
+
+};
+
+void WSS::init(int i){
+	int j;
+	maxOrder=i;
+	items= (1<<maxOrder)-1;
+	ptr=0;
+	pwss=(int*)malloc(sizeof(int)*items);
+	
+	for(j=1;j<=items; j++)
+		rawScan(j, 1, maxOrder,  (int*)(pwss+j-1));
+}
+
+int WSS::get(int order)  // it should also tells the WSS the order
+{  
+	int value;
+
+	currOrder=order;
+
+	//printf("get wss\n");
+	int tmp = 1 << order;
+	if((int)ptr > (tmp-2))
+	{
+		printf("tmp :%d \n", tmp);
+		printf("error, too large ptr:%d, order:%d\n", (int)ptr, order);
+		exit(0);
+	}
+
+	value= *(pwss+ptr);
+	return value;
+}
+
+void WSS::print(){
+	int i;
+	for(i=0;i<items;i++)
+		printf("%4d", *(pwss+i));
+	printf("\n");
+}
+
+/*
+main(int argc,  char **argv)
+{
+	WSS wss;
+	if(argc!=2)
+	{
+		printf("usage:%s number\n", argv[0]);
+		exit(0);
+	}
+	wss.init(atoi(argv[1]));
+	wss.print();
+}
+*/
--- satellite/satnode.cc	2001-11-06 01:21:47.000000000 -0500
+++ satellite/satnode.cc	2009-04-01 18:01:36.000000000 -0400
@@ -36,7 +36,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/satellite/satnode.cc,v 1.8 2001/11/06 06:21:47 tomh Exp $";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/satellite/satnode.cc,v 1.1.1.1 2008/04/11 18:40:30 rouil Exp $";
 #endif
 
 #include "satnode.h"
--- sctp/sctp.cc	2006-12-17 10:20:41.000000000 -0500
+++ sctp/sctp.cc	2009-04-01 18:01:36.000000000 -0400
@@ -36,7 +36,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp.cc,v 1.11 2006/12/17 15:20:41 mweigle Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctpDebug.cc	2005-07-18 14:28:34.000000000 -0400
+++ sctp/sctpDebug.cc	2009-04-01 18:01:36.000000000 -0400
@@ -34,7 +34,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctpDebug.cc,v 1.1 2005/07/18 18:28:34 tomh Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctpDebug.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 #include "sctpDebug.h"
--- sctp/sctpDebug.h	2006-06-23 10:28:40.000000000 -0400
+++ sctp/sctpDebug.h	2009-04-01 18:01:36.000000000 -0400
@@ -34,7 +34,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctpDebug.h,v 1.4 2006/06/23 14:28:40 tom_henderson Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctpDebug.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 #ifndef ns_sctpDebug_h
--- sctp/sctp.h	2006-12-17 10:19:21.000000000 -0500
+++ sctp/sctp.h	2009-04-01 18:01:36.000000000 -0400
@@ -33,7 +33,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp.h,v 1.9 2006/12/17 15:19:21 mweigle Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 #ifndef ns_sctp_h
--- sctp/sctp-hbAfterRto.cc	2005-10-07 01:58:29.000000000 -0400
+++ sctp/sctp-hbAfterRto.cc	2009-04-01 18:01:36.000000000 -0400
@@ -40,7 +40,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-hbAfterRto.cc,v 1.3 2005/10/07 05:58:29 tomh Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-hbAfterRto.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctp-hbAfterRto.h	2005-10-07 01:58:29.000000000 -0400
+++ sctp/sctp-hbAfterRto.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-hbAfterRto.h,v 1.2 2005/10/07 05:58:29 tomh Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-hbAfterRto.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 /* HbAfterRto extension sends a heartbeat immediately after timeout
--- sctp/sctp-mfrHbAfterRto.cc	2005-10-07 02:14:37.000000000 -0400
+++ sctp/sctp-mfrHbAfterRto.cc	2009-04-01 18:01:36.000000000 -0400
@@ -49,7 +49,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-mfrHbAfterRto.cc,v 1.1 2005/10/07 06:14:37 tomh Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-mfrHbAfterRto.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctp-mfrHbAfterRto.h	2005-10-07 02:14:38.000000000 -0400
+++ sctp/sctp-mfrHbAfterRto.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-mfrHbAfterRto.h,v 1.1 2005/10/07 06:14:38 tomh Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-mfrHbAfterRto.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 /* This extension combines MultipleFastRtx and HbAfterRto extensions.
--- sctp/sctp-mfrTimestamp.cc	2005-10-07 02:14:38.000000000 -0400
+++ sctp/sctp-mfrTimestamp.cc	2009-04-01 18:01:36.000000000 -0400
@@ -42,7 +42,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-mfrTimestamp.cc,v 1.1 2005/10/07 06:14:38 tomh Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-mfrTimestamp.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctp-mfrTimestamp.h	2005-10-07 02:14:38.000000000 -0400
+++ sctp/sctp-mfrTimestamp.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-mfrTimestamp.h,v 1.1 2005/10/07 06:14:38 tomh Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-mfrTimestamp.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 /* This extension combines MultipleFastRtx and Timestamp extensions.
--- sctp/sctp-multipleFastRtx.cc	2005-10-07 01:58:29.000000000 -0400
+++ sctp/sctp-multipleFastRtx.cc	2009-04-01 18:01:36.000000000 -0400
@@ -42,7 +42,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-multipleFastRtx.cc,v 1.3 2005/10/07 05:58:29 tomh Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-multipleFastRtx.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctp-multipleFastRtx.h	2005-10-07 01:58:29.000000000 -0400
+++ sctp/sctp-multipleFastRtx.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-multipleFastRtx.h,v 1.2 2005/10/07 05:58:29 tomh Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-multipleFastRtx.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 /* MultipleFastRtx extension implements the Caro Multiple Fast Retransmit
--- sctp/sctp-newreno.cc	2005-07-12 23:51:27.000000000 -0400
+++ sctp/sctp-newreno.cc	2009-04-01 18:01:36.000000000 -0400
@@ -40,7 +40,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-newreno.cc,v 1.3 2005/07/13 03:51:27 tomh Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-newreno.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctp-newreno.h	2003-08-21 14:29:14.000000000 -0400
+++ sctp/sctp-newreno.h	2009-04-01 18:01:36.000000000 -0400
@@ -32,7 +32,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-newreno.h,v 1.1 2003/08/21 18:29:14 haldar Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-newreno.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 /* NewReno extension introduces a recover state variable per destination
--- sctp/sctp.README	2003-08-21 14:29:14.000000000 -0400
+++ sctp/sctp.README	2009-04-01 18:01:36.000000000 -0400
@@ -3,7 +3,7 @@
 
 Please submit bug reports to pel@@cis,udel,edu
 
-@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp.README,v 1.1 2003/08/21 18:29:14 haldar Exp $
+@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp.README,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $
 
 
 ------------------------------------------------------------------------------
--- sctp/sctp-timestamp.cc	2006-02-21 10:20:20.000000000 -0500
+++ sctp/sctp-timestamp.cc	2009-04-01 18:01:36.000000000 -0400
@@ -40,7 +40,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-timestamp.cc,v 1.4 2006/02/21 15:20:20 mahrenho Exp $ (UD/PEL)";
+"@(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-timestamp.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)";
 #endif
 
 #include "ip.h"
--- sctp/sctp-timestamp.h	2005-10-07 01:58:29.000000000 -0400
+++ sctp/sctp-timestamp.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/sctp/sctp-timestamp.h,v 1.3 2005/10/07 05:58:29 tomh Exp $ (UD/PEL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/sctp/sctp-timestamp.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (UD/PEL)
  */
 
 /* Timestamp extension adds a TIMESTAMP chunk into every packet with DATA
--- tcl/edu/chan-interference/chanInterference.pl	2003-10-17 00:18:33.000000000 -0400
+++ tcl/edu/chan-interference/chanInterference.pl	2009-04-01 18:01:36.000000000 -0400
@@ -1,313 +1,313 @@
-sub usage {
-	print STDERR "usage: $0 <Base Trace file> <Base nam trace file> <output nam trace file>n";
-	exit;
-}
-
-#@ARGV[0] - source trace file
-#@ARGV[1] - source nam trace file
-#@ARGV[2] - output nam trace file
-
-open (Source, $ARGV[0]) or die "Cannot open $ARGV[0] : $!\n";
-open (NamSource, $ARGV[1]) or die "Cannot open $ARGV[1] : $!\n";
-open (Destination, ">$ARGV[2]") or die "Cannot open $ARGV[2]: $!\n";
-
-$namline = <NamSource>;
-while ($namline) { 
-	if ($namline =~ /-i 3 -n green/) {
-		print Destination $namline;
-		print Destination 'v -t 0.000 -e sim_annotation 0.0 1 COLOR LEGEND : ', "\n";
-		print Destination 'v -t 0.003 -e sim_annotation 0.003 2 Nodes turn red when there is a collision ', "\n";
-		print Destination 'v -t 0.10000000 -e set_rate_ext 0.200ms 1', "\n";
-		last;
-	}
-	else
-	{
-		print Destination $namline;
-		$namline = <NamSource>;
-	}
-}
-
-$num_mov = 0;
-
-$i =3;
-$one = 0;
-$two = 0;
-$three = 0;
-
-$last_time = 0.1500;
-$line = <Source>;
-while ($line) {
-	if ($line =~ /^M/) {
-		@fields = split ' ', $line;
-		@fields[3] =~ m/(\d+\.\d+)/;
-		@fields[3] = $1;
-		@fields[4] =~ m/(\d+\.\d+)/;
-		@fields[4] = $1;
-		@fields[6] =~ m/(\d+\.\d+)/;
-		@fields[6] = $1;
-		$t = (@fields[6] - @fields[3])/@fields[8];
-		if ($t < 0)
-		{
-			$t = -$t;
-		}
-		if(@fields[3] > @fields[6])
-		{
-		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -x ', @fields[3], ' -y ', @fields[4], ' -U -',@fields[8], ' -V 0.00 -T ', $t,"\n";
-		}
-		else
-		{
-		print Destination 'n -t ', @fields[1], ' -s ', @fields[2],' -x ',@fields[3],' -y ',@fields[4],' -U ',@fields[8],' -V 0.00 -T ',$t,"\n";
-		}
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1],' ', $i,' NODE 2 MOVES ',"\n";
-		$last_time = @fields[1]+0.00005;
-		$i++;
-		if ($num_mov == 0)
-		{
-			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 is out of range of Node 1',"\n";
-		}
-		if ($num_mov == 1)
-		{
-			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 is at the border range of Node 1',"\n";
-		}
-		if ($num_mov == 2)
-		{
-			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 is in range of Node 1, close enough to',"\n";
-			$last_time = $last_time + 0.00005;
-			$i++;
-		print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' interfere with Node 0 but not the same distance as Node 0 from Node 1',"\n";
-		}
-		$i++;
-
-		$num_mov ++;
-		$last_time = $last_time + 0.08;
-		$line = <Source>;
-	}
-	elsif ($num_mov < 1) { # Node 0 and Node 2 are equidistant from Node 1
-		if ($line =~ /SENSING_CARRIER/) {
-			@fields = split ' ', $line;
-			$next_line = <Source>;
-			if ($next_line =~ /BACKING_OFF/) {
-				$other_node = 2;
-				if (@fields[4] == 2)
-				{
-					$other_node = 0;
-				}
-				$t = $last_time +0.005;
-				print Destination 'v -t ', $t, ' -e sim_annotation ', $t,' ', $i,' CASE 1a : EQUIDISTANT : SEPARATE TIMES : SUCCESSFUL RECEPTION',"\n";
-				$last_time = $t+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 and Node 2 are in range of each other,',"\n"; 
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time, ' ', $i,' and are equidistant from Node 1, so when they both send packets at different times, the signal of these', "\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-		print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,'packets, at the receiver ,is the same, and hence packets from both senders are received',"\n";
-				$i++;
-				$next_duration = $last_time + 0.01;
-
-				print Destination '+ -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'r -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-
-				$next_duration = $next_duration + 0.01;
-				print Destination '+ -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'r -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-
-				$last_time = $next_duration;
-				$line = <Source>;
-			}
-			elsif ($next_line =~ /SENSING_CARRIER/) {
-				@new_fields = split ' ', $next_line;
-				$last_time = $last_time + 0.01;
-				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i,' CASE 1b : EQUIDISTANT - SAME TIME : COLLISION ',"\n";
-				$last_time = $last_time+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 and Node 2 want to send packets at the same time, since they are',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' the same distance from the receiver, the packets received are the same strength',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' and hence they interfere with each other resulting in collision',"\n";
-				$i++;
-
-				$duration = $last_time + 0.01;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$red_duration = $duration + 0.01;
-				$red_end_duration = $red_duration + 0.01;
-				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
-				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
-				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-				$last_time = $red_end_duration;
-				$line = <Source>;
-			}
-			else {
-				$line = <Source>;
-			}
-
-			}
-			else {
-			$line = <Source>;
-			}
-		}
-		elsif (($num_mov == 1) && ($one == 0)) { # Node 2 is out of range of Node 1
-				$duration = $last_time + 0.01;
-				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 2a : NODE 2 OUT OF RANGE , NODES SENDING PACKETS SEPARATELY ',"\n";
-				$last_time = $duration+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which are successfully received by Node 1',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$duration = $duration + 0.01;
-				$last_time = $duration + 0.00005;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 sends data packets to Node 1',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ', $last_time,' -e sim_annotation ',$last_time,' ',$i,'	but they are not recd. by Node 1, since Node 2 is out of range of Node 1  ',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				$duration = $duration + 0.01;
-
-				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 2b : NODE 2 OUT OF RANGE , NODES SENDING PACKETS AT THE SAME TIME ',"\n";
-				$last_time = $duration+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1 which',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' are successfully received by Node 1  and Node 2 sends packets to Node 1',"\n";
-			$last_time = $last_time + 0.00005;
-			$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' which are not received, because Node 2 is out of range of Node 1',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				$duration = $duration + 0.01;
-
-				$line = <Source>;
-				$last_time = $duration;
-				$one = 1;
-		}
-		elsif (($num_mov == 2) && ($two == 0)) # Node 2 is barely within range of Node 1
-		{
-				$duration = $last_time + 0.01;
-				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 3a : NODE 2 BARELY IN RANGE OF NODE 1 , NODES SENDING PACKETS SEPARATELY ',"\n";
-				$last_time = $duration+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which are successfully received by Node 1',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$duration = $duration + 0.01;
-				$last_time = $duration + 0.00005;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 sends data packets to Node 1 which are received successfully by Node 1 ',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$duration = $duration + 0.01;
-
-				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 3b : CHANNEL CAPTURE : NODE 2 BARELY IN RANGE OF NODE 1, NODES SENDING PACKETS AT THE SAME TIME ',"\n";
-				$last_time = $duration+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which',"\n";					$last_time = $last_time + 0.00005;
-				$i++;	
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' are successfully received by Node 1  and Node 2 sends packets to Node 1 which are not received, because',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' Node 0 being closer to Node 1, the signal strength of its packets is higher than that of Node 2 packets',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
-				$last_time = $duration;
-				$line = <Source>;
-
-				$two = 1;
-		}
-		elsif(($num_mov == 3) && ($three == 0))# Node 2 is close enough to interfere with Node 0
-		{
-				$duration = $last_time + 0.01;
-				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 4a : NODE 2 IN RANGE OF NODE 1 , NODES SENDING PACKETS SEPARATELY ',"\n";
-				$last_time = $duration+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which are successfully received by Node 1',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$duration = $duration + 0.01;
-				$last_time = $duration + 0.00005;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 sends data packets to Node 1 and they are received successfully by Node 1',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$duration = $duration + 0.01;
-
-				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 4b : NODE 2 IN RANGE OF NODE 1 , NODES SENDING PACKETS AT THE SAME TIME ',"\n";
-				$last_time = $duration+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1 the same',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' time that Node 2 sends packets to Node 1, and hence they collide at the reciever since',"\n";
-				$last_time = $last_time + 0.00005;
-				$i++; 
-			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,'their packets interfere with each other',"\n";
-				$i++;
-				$duration = $last_time + 0.00005;
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$duration = $duration + 0.01;
-				$red_duration = $duration + 0.01;
-				$red_end_duration = $red_duration + 0.01;
-				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
-				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
-				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-				$last_time = $red_end_duration;
-
-				$line = <Source>;
-
-				$three = 1;
-		}
-		else {
-			$line = <Source>;
-		}
-}
+sub usage {
+	print STDERR "usage: $0 <Base Trace file> <Base nam trace file> <output nam trace file>n";
+	exit;
+}
+
+#@ARGV[0] - source trace file
+#@ARGV[1] - source nam trace file
+#@ARGV[2] - output nam trace file
+
+open (Source, $ARGV[0]) or die "Cannot open $ARGV[0] : $!\n";
+open (NamSource, $ARGV[1]) or die "Cannot open $ARGV[1] : $!\n";
+open (Destination, ">$ARGV[2]") or die "Cannot open $ARGV[2]: $!\n";
+
+$namline = <NamSource>;
+while ($namline) { 
+	if ($namline =~ /-i 3 -n green/) {
+		print Destination $namline;
+		print Destination 'v -t 0.000 -e sim_annotation 0.0 1 COLOR LEGEND : ', "\n";
+		print Destination 'v -t 0.003 -e sim_annotation 0.003 2 Nodes turn red when there is a collision ', "\n";
+		print Destination 'v -t 0.10000000 -e set_rate_ext 0.200ms 1', "\n";
+		last;
+	}
+	else
+	{
+		print Destination $namline;
+		$namline = <NamSource>;
+	}
+}
+
+$num_mov = 0;
+
+$i =3;
+$one = 0;
+$two = 0;
+$three = 0;
+
+$last_time = 0.1500;
+$line = <Source>;
+while ($line) {
+	if ($line =~ /^M/) {
+		@fields = split ' ', $line;
+		@fields[3] =~ m/(\d+\.\d+)/;
+		@fields[3] = $1;
+		@fields[4] =~ m/(\d+\.\d+)/;
+		@fields[4] = $1;
+		@fields[6] =~ m/(\d+\.\d+)/;
+		@fields[6] = $1;
+		$t = (@fields[6] - @fields[3])/@fields[8];
+		if ($t < 0)
+		{
+			$t = -$t;
+		}
+		if(@fields[3] > @fields[6])
+		{
+		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -x ', @fields[3], ' -y ', @fields[4], ' -U -',@fields[8], ' -V 0.00 -T ', $t,"\n";
+		}
+		else
+		{
+		print Destination 'n -t ', @fields[1], ' -s ', @fields[2],' -x ',@fields[3],' -y ',@fields[4],' -U ',@fields[8],' -V 0.00 -T ',$t,"\n";
+		}
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1],' ', $i,' NODE 2 MOVES ',"\n";
+		$last_time = @fields[1]+0.00005;
+		$i++;
+		if ($num_mov == 0)
+		{
+			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 is out of range of Node 1',"\n";
+		}
+		if ($num_mov == 1)
+		{
+			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 is at the border range of Node 1',"\n";
+		}
+		if ($num_mov == 2)
+		{
+			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 is in range of Node 1, close enough to',"\n";
+			$last_time = $last_time + 0.00005;
+			$i++;
+		print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' interfere with Node 0 but not the same distance as Node 0 from Node 1',"\n";
+		}
+		$i++;
+
+		$num_mov ++;
+		$last_time = $last_time + 0.08;
+		$line = <Source>;
+	}
+	elsif ($num_mov < 1) { # Node 0 and Node 2 are equidistant from Node 1
+		if ($line =~ /SENSING_CARRIER/) {
+			@fields = split ' ', $line;
+			$next_line = <Source>;
+			if ($next_line =~ /BACKING_OFF/) {
+				$other_node = 2;
+				if (@fields[4] == 2)
+				{
+					$other_node = 0;
+				}
+				$t = $last_time +0.005;
+				print Destination 'v -t ', $t, ' -e sim_annotation ', $t,' ', $i,' CASE 1a : EQUIDISTANT : SEPARATE TIMES : SUCCESSFUL RECEPTION',"\n";
+				$last_time = $t+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 and Node 2 are in range of each other,',"\n"; 
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time, ' ', $i,' and are equidistant from Node 1, so when they both send packets at different times, the signal of these', "\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+		print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,'packets, at the receiver ,is the same, and hence packets from both senders are received',"\n";
+				$i++;
+				$next_duration = $last_time + 0.01;
+
+				print Destination '+ -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'r -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+
+				$next_duration = $next_duration + 0.01;
+				print Destination '+ -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'r -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+
+				$last_time = $next_duration;
+				$line = <Source>;
+			}
+			elsif ($next_line =~ /SENSING_CARRIER/) {
+				@new_fields = split ' ', $next_line;
+				$last_time = $last_time + 0.01;
+				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i,' CASE 1b : EQUIDISTANT - SAME TIME : COLLISION ',"\n";
+				$last_time = $last_time+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 and Node 2 want to send packets at the same time, since they are',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' the same distance from the receiver, the packets received are the same strength',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' and hence they interfere with each other resulting in collision',"\n";
+				$i++;
+
+				$duration = $last_time + 0.01;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$red_duration = $duration + 0.01;
+				$red_end_duration = $red_duration + 0.01;
+				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
+				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
+				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+				$last_time = $red_end_duration;
+				$line = <Source>;
+			}
+			else {
+				$line = <Source>;
+			}
+
+			}
+			else {
+			$line = <Source>;
+			}
+		}
+		elsif (($num_mov == 1) && ($one == 0)) { # Node 2 is out of range of Node 1
+				$duration = $last_time + 0.01;
+				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 2a : NODE 2 OUT OF RANGE , NODES SENDING PACKETS SEPARATELY ',"\n";
+				$last_time = $duration+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which are successfully received by Node 1',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$duration = $duration + 0.01;
+				$last_time = $duration + 0.00005;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 sends data packets to Node 1',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ', $last_time,' -e sim_annotation ',$last_time,' ',$i,'	but they are not recd. by Node 1, since Node 2 is out of range of Node 1  ',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				$duration = $duration + 0.01;
+
+				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 2b : NODE 2 OUT OF RANGE , NODES SENDING PACKETS AT THE SAME TIME ',"\n";
+				$last_time = $duration+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1 which',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' are successfully received by Node 1  and Node 2 sends packets to Node 1',"\n";
+			$last_time = $last_time + 0.00005;
+			$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' which are not received, because Node 2 is out of range of Node 1',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				$duration = $duration + 0.01;
+
+				$line = <Source>;
+				$last_time = $duration;
+				$one = 1;
+		}
+		elsif (($num_mov == 2) && ($two == 0)) # Node 2 is barely within range of Node 1
+		{
+				$duration = $last_time + 0.01;
+				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 3a : NODE 2 BARELY IN RANGE OF NODE 1 , NODES SENDING PACKETS SEPARATELY ',"\n";
+				$last_time = $duration+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which are successfully received by Node 1',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$duration = $duration + 0.01;
+				$last_time = $duration + 0.00005;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 sends data packets to Node 1 which are received successfully by Node 1 ',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$duration = $duration + 0.01;
+
+				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 3b : CHANNEL CAPTURE : NODE 2 BARELY IN RANGE OF NODE 1, NODES SENDING PACKETS AT THE SAME TIME ',"\n";
+				$last_time = $duration+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which',"\n";					$last_time = $last_time + 0.00005;
+				$i++;	
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' are successfully received by Node 1  and Node 2 sends packets to Node 1 which are not received, because',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' Node 0 being closer to Node 1, the signal strength of its packets is higher than that of Node 2 packets',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d -1 -p message -e 2500 -a 8 ', "\n";
+				$last_time = $duration;
+				$line = <Source>;
+
+				$two = 1;
+		}
+		elsif(($num_mov == 3) && ($three == 0))# Node 2 is close enough to interfere with Node 0
+		{
+				$duration = $last_time + 0.01;
+				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 4a : NODE 2 IN RANGE OF NODE 1 , NODES SENDING PACKETS SEPARATELY ',"\n";
+				$last_time = $duration+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1, which are successfully received by Node 1',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$duration = $duration + 0.01;
+				$last_time = $duration + 0.00005;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 2 sends data packets to Node 1 and they are received successfully by Node 1',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$duration = $duration + 0.01;
+
+				print Destination 'v -t ', $duration, ' -e sim_annotation ', $duration,' ', $i,' CASE 4b : NODE 2 IN RANGE OF NODE 1 , NODES SENDING PACKETS AT THE SAME TIME ',"\n";
+				$last_time = $duration+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 sends data packets to Node 1 the same',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,' time that Node 2 sends packets to Node 1, and hence they collide at the reciever since',"\n";
+				$last_time = $last_time + 0.00005;
+				$i++; 
+			print Destination 'v -t ',$last_time,' -e sim_annotation ',$last_time,' ',$i,'their packets interfere with each other',"\n";
+				$i++;
+				$duration = $last_time + 0.00005;
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$duration = $duration + 0.01;
+				$red_duration = $duration + 0.01;
+				$red_end_duration = $red_duration + 0.01;
+				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
+				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
+				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+				$last_time = $red_end_duration;
+
+				$line = <Source>;
+
+				$three = 1;
+		}
+		else {
+			$line = <Source>;
+		}
+}
--- tcl/edu/hidden-terminal/ht-post.pl	2003-09-19 13:14:01.000000000 -0400
+++ tcl/edu/hidden-terminal/ht-post.pl	2009-04-01 18:01:36.000000000 -0400
@@ -1,265 +1,265 @@
-# Script parses trace file for hidden terminal.
-# It sets colors to nodes and packets depending on their
-# state.
-# While doing carrier sense, nodes turn green. 
-# When nodes backoff, they turn purple.
-# When there is a collision at the reciever, it turns red.
-
-sub usage {
-	print STDERR "usage: $0 <Base Trace file> <Base nam trace file> <output nam trace file>n";
-	exit;
-}
-
-#@ARGV[0] - source trace file
-#@ARGV[1] - source nam trace file
-#@ARGV[2] - output nam trace file
-
-open (Source, $ARGV[0]) or die "Cannot open $ARGV[0] : $!\n";
-open (NamSource, $ARGV[1]) or die "Cannot open $ARGV[1] : $!\n";
-open (Destination, ">$ARGV[2]") or die "Cannot open $ARGV[2]: $!\n";
-
-$namline = <NamSource>;
-while ($namline) { 
-	if ($namline =~ /-i 3 -n green/) {
-		print Destination $namline;
-		print Destination 'v -t 0.000 -e sim_annotation 0.0 1 COLOR LEGEND : ', "\n";
-		print Destination 'v -t 0.001 -e sim_annotation 0.001 2 Nodes turn green when they are sensing carrier ', "\n";
-		print Destination 'v -t 0.002 -e sim_annotation 0.002 3 Nodes turn purple when they backoff ', "\n";
-		print Destination 'v -t 0.003 -e sim_annotation 0.003 4 Nodes turn red when there is a collision ', "\n";
-		print Destination 'v -t 0.10000000 -e set_rate_ext 0.200ms 1', "\n";
-		last;
-	}
-	else
-	{
-		print Destination $namline;
-		$namline = <NamSource>;
-	}
-}
-
-$num_mov = 0;
-
-$i =5;
-
-$last_time = 0.1000;
-$line = <Source>;
-while ($line) {
-	if ($line =~ /SENSING_CARRIER/) {  # parses the trace file in case of a Carrier Sense event.
-		@fields = split ' ', $line;
-		$next_line = <Source>;
-		if ($next_line =~ /BACKING_OFF/) { # parses trace file in case of a BACK_OFF event.
-			$other_node = 2;
-			if (@fields[4] == 2)
-			{
-				$other_node = 0;
-			}
-			
-			$t = @fields[2] +0.005;
-
-			print Destination 'n -t ',@fields[2], ' -s ', @fields[4], ' -S COLOR -c green -o black -I black ', "\n";
-			print Destination 'n -t ',@fields[2], ' -s ',@fields[4],' -S DLABEL -l "Carrier sense" -L ""', "\n";
-			print Destination 'v -t ',@fields[2], ' -e sim_annotation ', @fields[2],' ',$i,' CASE 1 : NO CONTENTION ',"\n";
-			$last_time = @fields[2]+ 0.00005;
-			$i++;
-			print Destination 'v -t ',$last_time,' -e sim_annotation ', $last_time,' ', $i,' Only Node 2 is sending data packets and therefore no contention',"\n";
-			$last_time = $last_time+0.00005;
-			$i++;
-			$next_duration = @fields[2] + 0.01;
-			
-			print Destination 'n -t ', $next_duration, ' -s ', @fields[4], ' -S COLOR -c black -o green -i black -I green ', "\n";
-			print Destination 'n -t ', $next_duration, ' -s ', @fields[4], ' -S DLABEL -l "" -L ""', "\n";
-			print Destination '+ -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination '- -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination 'h -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination 'r -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-
-			@fields[2] = $next_duration + 0.01;
-
-			print Destination 'n -t ', @fields[2], ' -s ', @fields[4], ' -S COLOR -c green -o black -i green -I black ', "\n";
-			print Destination 'n -t ', @fields[2], ' -s ', @fields[4], ' -S DLABEL -l "Carrier sense" -L ""', "\n";
-			print Destination 'v -t ', @fields[2], ' -e sim_annotation ', @fields[2],' ', $i,' CASE 2 : BACKOFF ',"\n";
-			$last_time = @fields[2]+0.00005;
-			$i++;
-			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 and Node 2 are in range of each other, they do carrier sense at slightly different times',"\n";
-			$last_time = $last_time + 0.00005;
-			$i++;
-			print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i,' so Node 0 finds the channel not free, and thus backs off', "\n";
-			$last_time = $last_time+0.00005;
-			$i++;
-			$next_duration = @fields[2] + 0.01;
-
-			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S COLOR -c green -o black -i green -I black ', "\n";
-			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S DLABEL -l "Carrier Sense" -L ""', "\n";
-
-			print Destination 'n -t ', $next_duration,' -s ', @fields[4], ' -S COLOR -c black -o green -i black -I green ', "\n";
-			print Destination 'n -t ', $next_duration, ' -s ', @fields[4], ' -S DLABEL -l "" -L ""', "\n";
-			print Destination '+ -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination '- -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination 'h -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination 'r -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
-
-			$next_duration = $next_duration + 0.005;
-			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S COLOR -c purple -o green -i purple -I green ', "\n";
-			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S DLABEL -l "Backing off" -L ""', "\n";
-
-			$next_duration = $next_duration + 0.005;
-			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S COLOR -c green -o purple -i green -I purple ', "\n";
-			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S DLABEL -l "Carrier sense" -L ""', "\n"; 			
-			$next_duration = $next_duration + 0.005;
-			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S COLOR -c black -o green -i black -I green ', "\n";
-			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S DLABEL -l "" -L ""', "\n";
-			print Destination '+ -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination '- -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination 'h -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-			print Destination 'r -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
-
-			$line = <Source>;
-		}
-		elsif (($next_line =~ /SENSING_CARRIER/) && ($num_mov == 0)) {
-				@new_fields = split ' ', $next_line;
-				print Destination 'n -t ', @new_fields[2] , ' -s 0 -S COLOR -c green -o black -i green -I black ',"\n";
-				print Destination 'n -t ', @new_fields[2], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
-				print Destination 'n -t ', @new_fields[2] , ' -s 2 -S COLOR -c green -o black -i green -I black ', "\n";
-				print Destination 'n -t ', @new_fields[2], ' -s 2 -S DLABEL -l "Carrier Sense" -L ""' , "\n";
-
-				print Destination 'v -t ', @new_fields[2], ' -e sim_annotation ', @new_fields[2],' ', $i,' CASE 3 : COLLISION WHEN NODES SEND AT SAME TIME  ',"\n";
-				$last_time = @new_fields[2]+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Sender nodes are in range of each other but they do carrier sense at the same time,  ',"\n";
-				$last_time = $last_time+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time, ' ',$i,' thus finding channel to be free , so they send packets at the same time and therefore result in collision at the receiver',"\n";
-				$i++;
-				$last_time = $last_time +0.00005;
-
-				$duration = @new_fields[2] + 0.01;
-				print Destination 'n -t ', $duration, ' -s 0 -S COLOR -c black -o green -i black -I green ', "\n";
-				print Destination 'n -t ', $duration, ' -s 0 -S DLABEL -l "" -L ""', "\n";
-				print Destination 'n -t ', $duration, ' -s 2 -S COLOR -c black -o green -i black -I green ', "\n";
-				print Destination 'n -t ', $duration, ' -s 2 -S DLABEL -l "" -L ""', "\n";
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$red_duration = $duration + 0.01;
-				$red_end_duration = $red_duration + 0.01;
-				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
-				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
-				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-				$line = <Source>;
-		}
-		elsif(($next_line !~ /SENSING_CARRIER/) && ($num_mov > 0)) {
-
-				print Destination 'n -t ', @fields[2] , ' -s 0 -S COLOR -c green -o black -i green -I black ',"\n";
-				print Destination 'n -t ', @fields[2], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
-				@fields[2] = @fields[2] + 0.005;
-				print Destination 'n -t ', @fields[2] , ' -s 2 -S COLOR -c green -o black -i green -I black ', "\n";
-				print Destination 'n -t ', @fields[2], ' -s 2 -S DLABEL -l "Carrier Sense" -L ""' , "\n";
-
-				print Destination 'v -t ', @fields[2], ' -e sim_annotation ', @fields[2],' ', $i,' CASE 4 : SUCCESSFUL TRANSMISSION WHEN NODES ARE OUT OF RANGE OF EACH OTHER',"\n";
-				$last_time = @fields[2]+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Sender nodes are out of range of each other ', "\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i, '  but they result in successful transmission since they send packets at different times',"\n";
-				$last_time = $last_time+0.00005;
-				$i++;
-			
-				$duration = @fields[2] + 0.005;
-				print Destination 'n -t ', $duration, ' -s 0 -S COLOR -c black -o green -i black -I green ', "\n";
-				print Destination 'n -t ', $duration, ' -s 0 -S DLABEL -l "" -L ""', "\n";
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-
-				$duration = $duration + 0.005;
-				print Destination 'n -t ', $duration, ' -s 2 -S COLOR -c black -o green -i black -I green ', "\n";
-				print Destination 'n -t ', $duration, ' -s 2 -S DLABEL -l "" -L ""', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$line = <Source>;
-				$line = <Source>;
-				$line = <Source>;
-		}
-		elsif(($next_line =~ /SENSING_CARRIER/) && ($num_mov > 0)) {
-				print Destination 'n -t ', @fields[2] , ' -s 0 -S COLOR -c green -o black -i green -I black ',"\n";
-				print Destination 'n -t ', @fields[2], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
-				print Destination 'n -t ', @fields[2] , ' -s 2 -S COLOR -c green -o black -i green -I black ', "\n";
-				print Destination 'n -t ', @fields[2], ' -s 2 -S DLABEL -l "Carrier Sense" -L ""' , "\n";
-
-
-				print Destination 'v -t ', @fields[2], ' -e sim_annotation ', @fields[2],' ', $i,' CASE 5 : COLLISION IN A HIDDEN TERMINAL SCENARIO',"\n";
-				$last_time = @fields[2]+0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Sender nodes are out of range of each other ', "\n";
-				$last_time = $last_time + 0.00005;
-				$i++;
-				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ', $i,' even though they both do carrier sense, they cannot hear each other and thus find the channel free ', "\n";
-				$i++;
-				$last_time = $last_time + 0.00005;
-				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i,' and they send packets at the same time, thus resulting in a collision at the receiver. ',"\n";
-				$last_time = $last_time+0.00005;
-				$i++;
-				$duration = @fields[2] + 0.005;
-				print Destination 'n -t ', $duration, ' -s 0 -S COLOR -c black -o green -i black -I green ', "\n";
-				print Destination 'n -t ', $duration, ' -s 0 -S DLABEL -l "" -L ""', "\n";
-				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
-
-				print Destination 'n -t ', $duration, ' -s 2 -S COLOR -c black -o green -i black -I green ', "\n";
-				print Destination 'n -t ', $duration, ' -s 2 -S DLABEL -l "" -L ""', "\n";
-				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
-				$red_duration = $duration + 0.01;
-				$red_end_duration = $red_duration + 0.01;
-				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
-				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
-				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
-				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-				$line = <Source>;
-				$line = <Source>;
-				$line = <Source>;
-		}
-
-		else {
-			$line = <Source>;
-		} 
-	}
-	elsif ($line =~ /^M/) {  # parses trace file when node moves.
-		@fields = split ' ', $line;
-		@fields[3] =~ m/(\d+\.\d+)/;
-		@fields[3] = $1;
-		@fields[4] =~ m/(\d+\.\d+)/;
-		@fields[4] = $1;
-		@fields[6] =~ m/(\d+\.\d+)/;
-		@fields[6] = $1;
-		$t = (@fields[6] - @fields[3])/@fields[8];
-
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1],' ', $i,' HIDDEN TERMINAL SCENARIO : Node 2 moves and hence is out of range of node 0',"\n";
-		$last_time = @fields[1]+0.00005;
-		$i++;
-
-		@fields[1] = @fields[1] + 0.005;
-		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -x ', @fields[3], ' -y ', @fields[4], ' -U ',@fields[8], ' -V 0.00 -T ', $t,"\n";
-		@fields[1] = @fields[1] + 0.100000;
-
-
-		$num_mov ++;
-		$line = <Source>;
-	}
-	else {
-		$line = <Source>;
-	}
-}
-
-close Source;
-close NamSource;
-close Destination;
+# Script parses trace file for hidden terminal.
+# It sets colors to nodes and packets depending on their
+# state.
+# While doing carrier sense, nodes turn green. 
+# When nodes backoff, they turn purple.
+# When there is a collision at the reciever, it turns red.
+
+sub usage {
+	print STDERR "usage: $0 <Base Trace file> <Base nam trace file> <output nam trace file>n";
+	exit;
+}
+
+#@ARGV[0] - source trace file
+#@ARGV[1] - source nam trace file
+#@ARGV[2] - output nam trace file
+
+open (Source, $ARGV[0]) or die "Cannot open $ARGV[0] : $!\n";
+open (NamSource, $ARGV[1]) or die "Cannot open $ARGV[1] : $!\n";
+open (Destination, ">$ARGV[2]") or die "Cannot open $ARGV[2]: $!\n";
+
+$namline = <NamSource>;
+while ($namline) { 
+	if ($namline =~ /-i 3 -n green/) {
+		print Destination $namline;
+		print Destination 'v -t 0.000 -e sim_annotation 0.0 1 COLOR LEGEND : ', "\n";
+		print Destination 'v -t 0.001 -e sim_annotation 0.001 2 Nodes turn green when they are sensing carrier ', "\n";
+		print Destination 'v -t 0.002 -e sim_annotation 0.002 3 Nodes turn purple when they backoff ', "\n";
+		print Destination 'v -t 0.003 -e sim_annotation 0.003 4 Nodes turn red when there is a collision ', "\n";
+		print Destination 'v -t 0.10000000 -e set_rate_ext 0.200ms 1', "\n";
+		last;
+	}
+	else
+	{
+		print Destination $namline;
+		$namline = <NamSource>;
+	}
+}
+
+$num_mov = 0;
+
+$i =5;
+
+$last_time = 0.1000;
+$line = <Source>;
+while ($line) {
+	if ($line =~ /SENSING_CARRIER/) {  # parses the trace file in case of a Carrier Sense event.
+		@fields = split ' ', $line;
+		$next_line = <Source>;
+		if ($next_line =~ /BACKING_OFF/) { # parses trace file in case of a BACK_OFF event.
+			$other_node = 2;
+			if (@fields[4] == 2)
+			{
+				$other_node = 0;
+			}
+			
+			$t = @fields[2] +0.005;
+
+			print Destination 'n -t ',@fields[2], ' -s ', @fields[4], ' -S COLOR -c green -o black -I black ', "\n";
+			print Destination 'n -t ',@fields[2], ' -s ',@fields[4],' -S DLABEL -l "Carrier sense" -L ""', "\n";
+			print Destination 'v -t ',@fields[2], ' -e sim_annotation ', @fields[2],' ',$i,' CASE 1 : NO CONTENTION ',"\n";
+			$last_time = @fields[2]+ 0.00005;
+			$i++;
+			print Destination 'v -t ',$last_time,' -e sim_annotation ', $last_time,' ', $i,' Only Node 2 is sending data packets and therefore no contention',"\n";
+			$last_time = $last_time+0.00005;
+			$i++;
+			$next_duration = @fields[2] + 0.01;
+			
+			print Destination 'n -t ', $next_duration, ' -s ', @fields[4], ' -S COLOR -c black -o green -i black -I green ', "\n";
+			print Destination 'n -t ', $next_duration, ' -s ', @fields[4], ' -S DLABEL -l "" -L ""', "\n";
+			print Destination '+ -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination '- -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination 'h -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination 'r -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+
+			@fields[2] = $next_duration + 0.01;
+
+			print Destination 'n -t ', @fields[2], ' -s ', @fields[4], ' -S COLOR -c green -o black -i green -I black ', "\n";
+			print Destination 'n -t ', @fields[2], ' -s ', @fields[4], ' -S DLABEL -l "Carrier sense" -L ""', "\n";
+			print Destination 'v -t ', @fields[2], ' -e sim_annotation ', @fields[2],' ', $i,' CASE 2 : BACKOFF ',"\n";
+			$last_time = @fields[2]+0.00005;
+			$i++;
+			print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Node 0 and Node 2 are in range of each other, they do carrier sense at slightly different times',"\n";
+			$last_time = $last_time + 0.00005;
+			$i++;
+			print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i,' so Node 0 finds the channel not free, and thus backs off', "\n";
+			$last_time = $last_time+0.00005;
+			$i++;
+			$next_duration = @fields[2] + 0.01;
+
+			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S COLOR -c green -o black -i green -I black ', "\n";
+			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S DLABEL -l "Carrier Sense" -L ""', "\n";
+
+			print Destination 'n -t ', $next_duration,' -s ', @fields[4], ' -S COLOR -c black -o green -i black -I green ', "\n";
+			print Destination 'n -t ', $next_duration, ' -s ', @fields[4], ' -S DLABEL -l "" -L ""', "\n";
+			print Destination '+ -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination '- -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination 'h -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination 'r -t ', $next_duration, ' -s ', @fields[4], ' -d 1 -p message -e 2500 -a 1 ', "\n";
+
+			$next_duration = $next_duration + 0.005;
+			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S COLOR -c purple -o green -i purple -I green ', "\n";
+			print Destination 'n -t ', $next_duration, ' -s ', $other_node, ' -S DLABEL -l "Backing off" -L ""', "\n";
+
+			$next_duration = $next_duration + 0.005;
+			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S COLOR -c green -o purple -i green -I purple ', "\n";
+			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S DLABEL -l "Carrier sense" -L ""', "\n"; 			
+			$next_duration = $next_duration + 0.005;
+			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S COLOR -c black -o green -i black -I green ', "\n";
+			print Destination 'n -t ',$next_duration,' -s ', $other_node,' -S DLABEL -l "" -L ""', "\n";
+			print Destination '+ -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination '- -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination 'h -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+			print Destination 'r -t ', $next_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 1 ', "\n";
+
+			$line = <Source>;
+		}
+		elsif (($next_line =~ /SENSING_CARRIER/) && ($num_mov == 0)) {
+				@new_fields = split ' ', $next_line;
+				print Destination 'n -t ', @new_fields[2] , ' -s 0 -S COLOR -c green -o black -i green -I black ',"\n";
+				print Destination 'n -t ', @new_fields[2], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
+				print Destination 'n -t ', @new_fields[2] , ' -s 2 -S COLOR -c green -o black -i green -I black ', "\n";
+				print Destination 'n -t ', @new_fields[2], ' -s 2 -S DLABEL -l "Carrier Sense" -L ""' , "\n";
+
+				print Destination 'v -t ', @new_fields[2], ' -e sim_annotation ', @new_fields[2],' ', $i,' CASE 3 : COLLISION WHEN NODES SEND AT SAME TIME  ',"\n";
+				$last_time = @new_fields[2]+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Sender nodes are in range of each other but they do carrier sense at the same time,  ',"\n";
+				$last_time = $last_time+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time, ' ',$i,' thus finding channel to be free , so they send packets at the same time and therefore result in collision at the receiver',"\n";
+				$i++;
+				$last_time = $last_time +0.00005;
+
+				$duration = @new_fields[2] + 0.01;
+				print Destination 'n -t ', $duration, ' -s 0 -S COLOR -c black -o green -i black -I green ', "\n";
+				print Destination 'n -t ', $duration, ' -s 0 -S DLABEL -l "" -L ""', "\n";
+				print Destination 'n -t ', $duration, ' -s 2 -S COLOR -c black -o green -i black -I green ', "\n";
+				print Destination 'n -t ', $duration, ' -s 2 -S DLABEL -l "" -L ""', "\n";
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$red_duration = $duration + 0.01;
+				$red_end_duration = $red_duration + 0.01;
+				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
+				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
+				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+				$line = <Source>;
+		}
+		elsif(($next_line !~ /SENSING_CARRIER/) && ($num_mov > 0)) {
+
+				print Destination 'n -t ', @fields[2] , ' -s 0 -S COLOR -c green -o black -i green -I black ',"\n";
+				print Destination 'n -t ', @fields[2], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
+				@fields[2] = @fields[2] + 0.005;
+				print Destination 'n -t ', @fields[2] , ' -s 2 -S COLOR -c green -o black -i green -I black ', "\n";
+				print Destination 'n -t ', @fields[2], ' -s 2 -S DLABEL -l "Carrier Sense" -L ""' , "\n";
+
+				print Destination 'v -t ', @fields[2], ' -e sim_annotation ', @fields[2],' ', $i,' CASE 4 : SUCCESSFUL TRANSMISSION WHEN NODES ARE OUT OF RANGE OF EACH OTHER',"\n";
+				$last_time = @fields[2]+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Sender nodes are out of range of each other ', "\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i, '  but they result in successful transmission since they send packets at different times',"\n";
+				$last_time = $last_time+0.00005;
+				$i++;
+			
+				$duration = @fields[2] + 0.005;
+				print Destination 'n -t ', $duration, ' -s 0 -S COLOR -c black -o green -i black -I green ', "\n";
+				print Destination 'n -t ', $duration, ' -s 0 -S DLABEL -l "" -L ""', "\n";
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+
+				$duration = $duration + 0.005;
+				print Destination 'n -t ', $duration, ' -s 2 -S COLOR -c black -o green -i black -I green ', "\n";
+				print Destination 'n -t ', $duration, ' -s 2 -S DLABEL -l "" -L ""', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$line = <Source>;
+				$line = <Source>;
+				$line = <Source>;
+		}
+		elsif(($next_line =~ /SENSING_CARRIER/) && ($num_mov > 0)) {
+				print Destination 'n -t ', @fields[2] , ' -s 0 -S COLOR -c green -o black -i green -I black ',"\n";
+				print Destination 'n -t ', @fields[2], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
+				print Destination 'n -t ', @fields[2] , ' -s 2 -S COLOR -c green -o black -i green -I black ', "\n";
+				print Destination 'n -t ', @fields[2], ' -s 2 -S DLABEL -l "Carrier Sense" -L ""' , "\n";
+
+
+				print Destination 'v -t ', @fields[2], ' -e sim_annotation ', @fields[2],' ', $i,' CASE 5 : COLLISION IN A HIDDEN TERMINAL SCENARIO',"\n";
+				$last_time = @fields[2]+0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ',$i,' Sender nodes are out of range of each other ', "\n";
+				$last_time = $last_time + 0.00005;
+				$i++;
+				print Destination 'v -t ', $last_time,' -e sim_annotation ', $last_time,' ', $i,' even though they both do carrier sense, they cannot hear each other and thus find the channel free ', "\n";
+				$i++;
+				$last_time = $last_time + 0.00005;
+				print Destination 'v -t ', $last_time, ' -e sim_annotation ', $last_time,' ', $i,' and they send packets at the same time, thus resulting in a collision at the receiver. ',"\n";
+				$last_time = $last_time+0.00005;
+				$i++;
+				$duration = @fields[2] + 0.005;
+				print Destination 'n -t ', $duration, ' -s 0 -S COLOR -c black -o green -i black -I green ', "\n";
+				print Destination 'n -t ', $duration, ' -s 0 -S DLABEL -l "" -L ""', "\n";
+				print Destination '+ -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 0 -d 1 -p message -e 2500 -a 1 ', "\n";
+
+				print Destination 'n -t ', $duration, ' -s 2 -S COLOR -c black -o green -i black -I green ', "\n";
+				print Destination 'n -t ', $duration, ' -s 2 -S DLABEL -l "" -L ""', "\n";
+				print Destination '+ -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination '- -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				print Destination 'h -t ', $duration, ' -s 2 -d 1 -p message -e 2500 -a 1 ', "\n";
+				$red_duration = $duration + 0.01;
+				$red_end_duration = $red_duration + 0.01;
+				print Destination 'n -t ', $red_duration, ' -s 1 -S COLOR -c red -o black -i red -I black ', "\n";
+				print Destination 'n -t ', $red_duration, ' -s 1 -S DLABEL -l "Collision " -L ""', "\n";
+				print Destination 'd -t ', $red_duration, ' -s 1 -d 2 -p message -e 5000 -a 8 ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S COLOR -c black -o red -i black -I red ', "\n";
+				print Destination 'n -t ', $red_end_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+				$line = <Source>;
+				$line = <Source>;
+				$line = <Source>;
+		}
+
+		else {
+			$line = <Source>;
+		} 
+	}
+	elsif ($line =~ /^M/) {  # parses trace file when node moves.
+		@fields = split ' ', $line;
+		@fields[3] =~ m/(\d+\.\d+)/;
+		@fields[3] = $1;
+		@fields[4] =~ m/(\d+\.\d+)/;
+		@fields[4] = $1;
+		@fields[6] =~ m/(\d+\.\d+)/;
+		@fields[6] = $1;
+		$t = (@fields[6] - @fields[3])/@fields[8];
+
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1],' ', $i,' HIDDEN TERMINAL SCENARIO : Node 2 moves and hence is out of range of node 0',"\n";
+		$last_time = @fields[1]+0.00005;
+		$i++;
+
+		@fields[1] = @fields[1] + 0.005;
+		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -x ', @fields[3], ' -y ', @fields[4], ' -U ',@fields[8], ' -V 0.00 -T ', $t,"\n";
+		@fields[1] = @fields[1] + 0.100000;
+
+
+		$num_mov ++;
+		$line = <Source>;
+	}
+	else {
+		$line = <Source>;
+	}
+}
+
+close Source;
+close NamSource;
+close Destination;
--- tcl/edu/hidden-terminal/SimpleHiddenTerminaldescription	2003-09-02 17:35:26.000000000 -0400
+++ tcl/edu/hidden-terminal/SimpleHiddenTerminaldescription	2009-04-01 18:01:36.000000000 -0400
@@ -1,51 +1,51 @@
-Hidden Terminal
-----------------
-
-The problem of hidden terminal arises when 
-two sender nodes out of range of each other transmit packets at the
-same time, to the same receiver, resulting in collisions at the
-receiver.
-Since sender nodes are out of range of each other, they donot detect
-carrier even though the other node is sending data, and if their
-data packets reach the destination at the same time, these packets
-are dropped due to collision at the receiver.
-
-In our animation, we consider 4 cases :
-
-Case 1 :
---------
-When 2 nodes are in range of each other and they do carrier
-sense at different times.
-In this case, since sender nodes are in range of each other,
-they are able to detect carrier and hence one node which
-does carrier sense a little later than the other one, backs off,
-thus deferring transmission.
-As a result, their is no collision at the receiver.
-
-Case 2 :
---------
-When 2 nodes are in range of each other but they do carrier sense
-at the same time. 
-In this case, since sender nodes do carrier sense at the same time,
-neither of the nodes is able to detect carrier, hence they both send
-data packets to the receiver at the same time, thus causing a collision
-at the receiver. Here we assume, data packets reach the destination
-at the same time.
-
-Case 3:
--------
-When 2 nodes are out of range of each other and they do carrier sense
-at different times.
-In this case, since both nodes are out of range of each other, they 
-donot detect carrier, but since they do carrier sense at different times,
-thus sending data packets at different times, their data packets reach
-the destination at different times, thus avoiding a collision at the
-reciever.
-
-Case 4:
--------
-When 2 nodes are out of range of each other and they do carrier sense at
-the same time
-Here, since nodes are out of range of each other, they donot detect carrier,
-and their data packets reach the destiantion at the same distance, thus
+Hidden Terminal
+----------------
+
+The problem of hidden terminal arises when 
+two sender nodes out of range of each other transmit packets at the
+same time, to the same receiver, resulting in collisions at the
+receiver.
+Since sender nodes are out of range of each other, they donot detect
+carrier even though the other node is sending data, and if their
+data packets reach the destination at the same time, these packets
+are dropped due to collision at the receiver.
+
+In our animation, we consider 4 cases :
+
+Case 1 :
+--------
+When 2 nodes are in range of each other and they do carrier
+sense at different times.
+In this case, since sender nodes are in range of each other,
+they are able to detect carrier and hence one node which
+does carrier sense a little later than the other one, backs off,
+thus deferring transmission.
+As a result, their is no collision at the receiver.
+
+Case 2 :
+--------
+When 2 nodes are in range of each other but they do carrier sense
+at the same time. 
+In this case, since sender nodes do carrier sense at the same time,
+neither of the nodes is able to detect carrier, hence they both send
+data packets to the receiver at the same time, thus causing a collision
+at the receiver. Here we assume, data packets reach the destination
+at the same time.
+
+Case 3:
+-------
+When 2 nodes are out of range of each other and they do carrier sense
+at different times.
+In this case, since both nodes are out of range of each other, they 
+donot detect carrier, but since they do carrier sense at different times,
+thus sending data packets at different times, their data packets reach
+the destination at different times, thus avoiding a collision at the
+reciever.
+
+Case 4:
+-------
+When 2 nodes are out of range of each other and they do carrier sense at
+the same time
+Here, since nodes are out of range of each other, they donot detect carrier,
+and their data packets reach the destiantion at the same distance, thus
 causing a collision and hence drop of packets.--- tcl/edu/rts-cts/rts-cts-data-ack.pl	2003-09-19 13:14:21.000000000 -0400
+++ tcl/edu/rts-cts/rts-cts-data-ack.pl	2009-04-01 18:01:36.000000000 -0400
@@ -1,510 +1,510 @@
-# Script parses the trace file and using the base nam
-# file, it generates a nam file that sets colors to
-# nodes and data packets depending on their state.
-# When a node is doing carrier sense, it turns red.
-# When a node is sending RTS packets, it turns purple.
-# RTS packets are purple broadcas packets.
-# When a node is sending CTS packets, it turns green.
-# CTS packets are green broadcast packets.
-# When a node is sending data packets, it turns tan.
-# Data packets are tan in color.
-# When a node is sending ACK packets, it turns orange.
-# ACK packets are orange in color.
-sub usage {
-	print STDERR "usage: $0 <Base trace file> <Base nam trace file> <output nam trace file>n";
-	exit;
-}
-
-#@ARGV[0] - source trace file
-#@ARGV[1] - source nam trace file
-#@ARGV[2] - output nam trace file
-
-open (Nam, $ARGV[1]) or die "Cannot open $ARGV[1] : $!\n";
-open (Source, $ARGV[0]) or die "Cannot open $ARGV[0] : $!\n";
-open (Destination, ">$ARGV[2]") or die "Cannot open $ARGV[2]: $!\n";
-
-
-$line = <Nam>;
-$tp =0;
-while (($line) && ($tp ==0)) { 
-	if ($line =~ /-i 3 -n green/) {
-		print Destination $line;
-		print Destination 'v -t 0.0 -e set_rate_ext 0.550ms 1', "\n";
-		print Destination 'v -t 0.0 -e sim_annotation 0.0 1 In a Wireless network topology,when not all nodes are within each other\'s range, ',"\n";
-		print Destination 'v -t 0.01 -e sim_annotation 0.001 2 carrier sense only provides information about collisions at the sender,not at ', "\n";
-		print Destination 'v -t 0.015 -e sim_annotation 0.002 3 the receiver. This leads to problems like hidden terminal where two sender ', "\n";
-		print Destination 'v -t 0.02 -e sim_annotation 0.003 4 nodes out of range of each other transmit packets at the same time, ', "\n";
-		print Destination 'v -t 0.025 -e sim_annotation 0.004 5 to the same receiver, resulting in  collisions at the receiver. To solve ', "\n";
- 		print Destination 'v -t 0.03 -e sim_annotation 0.005 6 such problems, control packets, RTS & CTS are used. When a node wants to ', "\n";
-		print Destination 'v -t 0.035 -e sim_annotation 0.006 7 transmit packets, it first sends a RTS packet to the receiver.All nodes within ', "\n";
-		print Destination 'v -t 0.04 -e sim_annotation 0.007 8 the sender\'s range receive this RTS packet. Every node hearing this RTS packet ', "\n";
-		print Destination 'v -t 0.045 -e sim_annotation 0.008 9 will defer transmission. If receiver is not receiving data from any other node, ', "\n";
-		print Destination 'v -t 0.05 -e sim_annotation 0.009 10 it responds with a CTS packet.This packet is again received by every node ', "\n";
-		print Destination 'v -t 0.055 -e sim_annotation 0.01 11 within range of receiver. So all nodes in this range defer transmission. ', "\n";
-		print Destination 'v -t 0.06 -e sim_annotation 0.02 12 Sender node sends data packet after receiving CTS. If sender node does not ', "\n";
-		print Destination 'v -t 0.065 -e sim_annotation 0.03 13 hear the CTS, it will time-out and schedule retransmission of RTS. On ', "\n";
-		print Destination 'v -t 0.07 -e sim_annotation 0.04 14 receiving data packet, receiver sends an ACK to sender.  ', "\n";
-		$tp = 1;
-	}
-	else
-	{
-		print Destination $line;
-		$line = <Nam>;
-	}
-}
-
-print Destination 'v -t 0.100 -e sim_annotation 0.100 18 COLOR LEGEND : ', "\n";
-print Destination 'v -t 0.110 -e sim_annotation 0.110 19 RTS packets : Purple color. Node turns purple  while sending an RTS packet ', "\n";
-print Destination 'v -t 0.120 -e sim_annotation 0.120 20 CTS packets : Green color . Node turns  green while sending CTS packets ', "\n";
-print Destination 'v -t 0.130 -e sim_annotation 0.130 21 Data packets : Tan color . Node turns tan while sending data packets ', "\n";
-print Destination 'v -t 0.140 -e sim_annotation 0.140 22 ACK packets : Orange color. Node turns  orange while sending ACK packets ', "\n";
-$line = <Source>;
-@fields = split ' ', $line;
-my $temp = @fields[1];
-my $i = 23;
-my $t = 1;
-my $dw = 0;
-my $num_mov = 0;
-my $come = 0;
-my $once = 0;
-
-while($line) {
-	@fields = split ' ', $line;
-	@fields[1] = $temp + 0.005;
-	# This generates movement of node in name file.
-	if ($line =~ /^M/)
-	{
-		@fields[3] =~ m/(\d+\.\d+)/;
-		@fields[3] = $1;
-		@fields[4] =~ m/(\d+\.\d+)/;
-		@fields[4] = $1;
-		@fields[6] =~ m/(\d+\.\d+)/;
-		@fields[6] = $1;
-		$t = (@fields[6] - @fields[3])/@fields[8];
-		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -x ', @fields[3], ' -y ', @fields[4], ' -U ',@fields[8], ' -V 0.00 -T ', $t,"\n";
-		$num_mov ++;
-		if($num_mov == 1)
-			{
-			print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' NODE MOVES : Sender nodes can hear both RTS and CTS ', "\n";
-		$i++;
-			}
-		elsif ($num_mov == 2)
-			{
-			print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' NODE MOVES : Sender nodes can hear CTS but not RTS', "\n";
-		$i++;
-			}
-		$line = <Source>;
-		$temp = @fields[1];
-	}
-	elsif( # This parses the trace file for RTS packets before node moves.
-		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /RTS/) && (@fields[2] !~ /1/) && ($num_mov <= 1)
-	   ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$other_node = 0;
-		if (@fields[2] == 0)
-		{
-			$other_node = 2;
-		}
-		if ($come == 0)
-		{
-		$come = 1;
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' CASE 1 : NO CONTENTION. ', "\n";
-		$i++;
-		@fields[1] = @fields[1] + 0.00005;
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' Only one node sends data, it does a simple RTS-CTS_DATA-ACK exchange ', "\n";
-		$i++;
-		@fields[1] = @fields[1] + 0.00005; 
-		print Destination 'n -t ', @fields[1], ' -s 0 -S COLOR -c red -o black -i red -I black', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
-		$duration = @fields[1] + 0.005;
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c purple -o red -i purple -I red', "\n";
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
-		print Destination '+ -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination '- -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'h -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'r -t ', $duration, ' -s ', @fields[2], ' -d -1 p message -e 500 -a 7', "\n";
-		$new_duration = $duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o purple -i black -I purple', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
-		$new_duration = $new_duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
-		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
-		print Destination '+ -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination '- -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'h -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'r -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		$new_duration = $new_duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
-		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$new_duration = $new_duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c tan -o black -i tan -I black', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending Data Packet" -L ""', "\n";
-		print Destination '+ -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination '- -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination 'h -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination 'r -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		$new_duration = $new_duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o tan -i black -I tan', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
-		$new_duration = $new_duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
-		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
-		print Destination '+ -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination '- -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'h -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'r -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		$new_duration = $new_duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c black -o orange -i black -I orange', "\n";
-		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		print Destination 'v -t ', $new_duration, ' -e sim_annotation ', $new_duration, ' ', $i, ' CASE 2 : BACKOFF DUE TO RTS', "\n"; 
-		$i++;
-		$new_duration = $new_duration + 0.005;
-		print Destination 'v -t ', $new_duration , ' -e sim_annotation ', $new_duration, ' ' , $i, ' Nodes are in RTS range of each other but not in CTS range of the receiver ', "\n";
-		$i++;
-		$new_duration = $new_duration + 0.005;
-		print Destination 'v -t ', $new_duration , ' -e sim_annotation ', $new_duration, ' ', $i, ' Node 0 want to send data to Node 1 at the same time that Node 2 wants to send data to Node 0 ', "\n";
-		$i++;
-		$new_duration = $new_duration + 0.005;
-		print Destination 'v -t ', $new_duration, ' -e sim_annotation ', $new_duration, ' ', $i, ' thus Node 2 backsoff when it hears the RTS from Node 0', "\n";
-		$i ++;
-		$temp = $new_duration;
-		@fields[1] = $new_duration + 0.01;
-		}
-		if($num_mov == 1)
-		{
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' CASE 3 : BACKOFF AGAIN DUE TO RTS', "\n";
-		$i++;
-		$new_duration = @fields[1] + 0.00005;
-		print Destination 'v -t ', $new_duration, ' -e sim_annotation ', $new_duration, ' ', $i, ' All nodes are in the RTS and CTS range of each other', "\n";
-		$i++;
-		$new_duration = $new_duration + 0.00005;
-		print Destination 'v -t ', $new_duration, ' -e sim_annotation  ', $new_duration, ' ' , $i, ' Nodes 0 and 2 are in range of each other and hence can hear the RTS packet of the other node after hearing RTS packet node backs off', "\n";
-		$i ++;
-		@fields[1] = $new_duration + 0.01;
-		}
-		print Destination 'n -t ', @fields[1], ' -s 0 -S COLOR -c red -o black -i red -I black', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 2 -S COLOR -c red -o black -i red -I black', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 2 -S DLABEL -l "Carrier sense" -L ""', "\n";
-		$duration = @fields[1] + 0.005;
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c purple -o red -i purple -I red', "\n";
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
-		print Destination '+ -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination '- -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'h -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'r -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-
-		$new_duration = $duration + 0.01;
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o purple -i black -I purple', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
-
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c DarkOliveGreen -o red -i DarkOliveGreen -I red', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "Data Waiting" -L ""', "\n";
-		$i ++;
-		$line = <Source>;
-		$temp = $new_duration;
-		}
-	elsif( # This parses trace file for RTS packets after node moves
-		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /RTS/) && (@fields[2] !~ /1/) && ($num_mov > 1)
-	  ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$other_node = 0;
-		if (@fields[2] == 0)
-		{
-			$other_node = 2;
-		}
-		if ($once == 0) {
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation  ', @fields[1], ' ' , $i, ' CASE 4 : BACKOFF DUE TO CTS ', "\n";
-		$i++;
-		@fields[1] = @fields[1] + 0.005;
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' Senders are out of range of RTS of each other but are in  range of CTS of receiver', "\n";
-		$i ++;
-		@fields[1] = @fields[1] + 0.005;
-		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' Node 0 sends RTS which Node 2 does not hear but it hears the CTS sent by receiver and thus backsoff after hearing CTS, thus avoiding collision at the receiver', "\n";
-		$i ++;
-		@fields[1] = @fields[1] + 0.005;
-
-		$once ++;
-		}
-		if ($dw == 0) {
-			print Destination 'n -t ', @fields[1], ' -s 0 -S COLOR -c red -o black -i red -I black', "\n";
-			print Destination 'n -t ', @fields[1], ' -s 2 -S COLOR -c red -o black -i red -I black', "\n";
-			print Destination 'n -t ', @fields[1], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
-			print Destination 'n -t ', @fields[1], ' -s 2 -S DLABEL -l "Carrier sense" -L ""', "\n";
-		}
-		if($dw == 1) {
-			print Destination 'n -t ', @fields[1],' -s ', @fields[2],' -S COLOR -c red -o black -i red -I black', "\n";
-			print Destination 'n -t ', @fields[1],' -s ', @fields[2],' -S DLABEL -l "Carrier sense" -L ""', "\n";
-		}
-
-		$duration = @fields[1] + 0.005;
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c purple -o red -i purple -I red', "\n";
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
-		print Destination '+ -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination '- -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'h -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'r -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
-		$new_duration = $duration + 0.005;
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o purple -i black -I purple', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
-		$temp = $new_duration;
-		if ($t == 1) {
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c purple -o red -i purple -I red', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
-		print Destination '+ -t ', $new_duration, ' -s ', $other_node, ' -d  -1 -p message -e 500 -a 7', "\n";
-		print Destination '- -t ', $new_duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'h -t ', $new_duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'r -t ', $new_duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		$final_duration = $new_duration + 0.005;
-		print Destination 'n -t ', $final_duration, ' -s ', $other_node, ' -S COLOR -c black -o purple -i black -I purple', "\n";
-		print Destination 'n -t ', $final_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L ""', "\n";
-		$t++;
-		$temp = $final_duration;
-		}
-		$line = <Source>;
-	    }
-	elsif( # This parses trace file for CTS packets after node moves
-		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /CTS/) && (@fields[2] !~ /0/) && (@fields[2] !~ /2/) && ($num_mov >= 1)
-	     ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$jitter = @fields[1] + 0.01;
-		print Destination 'n -t ', $jitter, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
-		print Destination 'n -t ', $jitter, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
-		print Destination '+ -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination '- -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'h -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'r -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		$duration = $jitter + 0.01;
-		print Destination 'n -t ', $duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
-		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$i++;
-		$line = <Source>;
-		$temp = $duration;
-		}
-	elsif( # This parses trace file for CTS packets after node moves
-		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /CTS/) && (@fields[2] !~ /0/) && (@fields[2] !~ /2/) && ($num_mov == 0)
-	     ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$jitter = @fields[1] + 0.01;
-
-		print Destination 'n -t ', $jitter, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
-		print Destination 'n -t ', $jitter, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
-		print Destination '+ -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination '- -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'h -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'r -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		$duration = $jitter + 0.01;
-		print Destination 'n -t ', $duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
-		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$i++;
-		$line = <Source>;
-		$temp = $duration;
-		}
-	elsif( # This parses trace file for data packets
-		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /message/) && (@fields[2] !~ /1/)
-	     ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$other_node = 0;
-		if(@fields[2] == 0) {
-			$other_node = 2;
-		}
-		@fields[1] = @fields[1] +0.01;
-		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -S DLABEL -l "Sending Data packets" -L ""', "\n";
-		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -S COLOR -c tan -o black -i tan -I black', "\n";
-		if(($num_mov > 1) && ($dw == 0)) {
-			print Destination 'n -t ', @fields[1], ' -s ', $other_node, ' -S COLOR -c DarkOliveGreen -o black -i DarkOliveGreen -I black', "\n";
-			print Destination 'n -t ', @fields[1], ' -s ', $other_node, ' -S DLABEL -l "Data waiting" -L ""', "\n";
-		}
-		print Destination '+ -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination '- -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination 'h -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination 'r -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
-		$duration = @fields[1] + 0.01;
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c black -o tan -i black -I tan', "\n";
-		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L "" ', "\n";
-		$i++;
-		$line = <Source>;
-		$temp = $duration;
-		}
-	elsif( # This parses trace file for ACK packets
-		($line =~ /r/) && ($line =~ /MAC/) && ($line =~ /ACK/) && (@fields[2] !~ /1/) && ($num_mov > 1)
-	     ) {
-		$dw ++;
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		print Destination 'n -t ', @fields[1], ' -s 1 -S DLABEL -l "Sending ACK packets" -L ""', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
-		print Destination '+ -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination '- -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'h -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'r -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		$duration = @fields[1] + 0.01;
-		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
-		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$i++;
-		$line = <Source>;
-		$temp = $duration;
-		}
-	elsif( # This parses trace file for ACK packets.
-		($line =~ /r/) && ($line =~ /MAC/) && ($line =~ /ACK/) && (@fields[2] !~ /1/) && ($num_mov == 0)
-	     ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$other_node = 0;
-		if(@fields[2] == 0) {
-			$other_node = 2;
-		}
-		print Destination 'n -t ', @fields[1], ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
-		print Destination '+ -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination '- -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'h -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'r -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		$duration = @fields[1] + 0.01;
-		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
-		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$i++;
-
-
-		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S COLOR -c purple -o DarkOliveGreen -i purple -I DarkOliveGreen', "\n";
-		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
-		print Destination '+ -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination '- -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'h -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'r -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		$new_duration = $duration + 0.005;
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c black -o purple -i black -I purple', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L ""', "\n";
-		$i ++;
-
-		$jitter = $new_duration + 0.01;
-		print Destination 'n -t ', $jitter, ' -s ', @fields[2], ' -S DLABEL -l "Sending CTS packets" -L ""', "\n";
-		print Destination 'n -t ', $jitter, ' -s ', @fields[2], ' -S COLOR -c green -o black -i green -I black', "\n";
-		print Destination '+ -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
-		print Destination '- -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'h -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'r -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
-		$n_duration = $jitter + 0.01;
-		print Destination 'n -t ', $n_duration, ' -s ', @fields[2], ' -S COLOR -c black -o green -i black -I green', "\n";
-		print Destination 'n -t ', $n_duration, ' -s ', @fields[2],' -S DLABEL -l "" -L ""', "\n";
-		$i++;
-
-		$n_duration = $n_duration + 0.005;
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "Sending Data packets" -L ""', "\n";
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c tan -o DarkOliveGreen -i tan -I DarkOliveGreen', "\n";
-
-		print Destination '+ -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
-		print Destination '- -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
-		print Destination 'h -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
-		print Destination 'r -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
-		$n_duration = $n_duration + 0.01;
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c black -o tan -i black -I tan', "\n";
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L "" ', "\n";
-		$i++;
-
-		$n_duration = $n_duration + 0.01;
-		print Destination 'n -t ', $n_duration, ' -s ', @fields[2],' -S DLABEL -l "Sending ACK packet" -L ""', "\n";
-		print Destination 'n -t ', $n_duration, ' -s ', @fields[2],' -S COLOR -c orange -o black -i orange -I black', "\n";
-		print Destination '+ -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		print Destination '- -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		print Destination 'h -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		print Destination 'r -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		$duration = $n_duration + 0.01;
-		print Destination 'n -t ', $duration, ' -s ', @fields[2],'  -S COLOR -c black -o orange -i black -I orange', "\n";
-		print Destination 'n -t ', $duration, ' -s ', @fields[2],' -S DLABEL -l "" -L ""', "\n";
-		$i++;
-
-
-
-		$line = <Source>;
-		$temp = $duration;
-
-		}
-	elsif(
-		($line =~ /r/) && ($line =~ /MAC/) && ($line =~ /ACK/) && (@fields[2] !~ /1/) && ($num_mov == 1)
-	     ) {
-		@fields[2] =~ m/(\d)/;
-		@fields[2] = $1;
-		$other_node = 0;
-		if(@fields[2] == 0) {
-			$other_node = 2;
-		}
-		print Destination 'n -t ', @fields[1], ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
-		print Destination 'n -t ', @fields[1], ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
-		print Destination '+ -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination '- -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'h -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		print Destination 'r -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
-		$duration = @fields[1] + 0.01;
-		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
-		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$i++;
-
-		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S COLOR -c purple -o DarkOliveGreen -i purple -I DarkOliveGreen', "\n";
-		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
-
-		print Destination '+ -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination '- -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'h -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-		print Destination 'r -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
-
-		$new_duration = $duration + 0.005;
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c black -o purple -i black -I purple', "\n";
-		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L ""', "\n";
-		$i ++;
-
-		$jitter = $new_duration + 0.01;
-		print Destination 'n -t ', $jitter, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
-		print Destination 'n -t ', $jitter, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
-		print Destination '+ -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination '- -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'h -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		print Destination 'r -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
-		$n_duration = $jitter + 0.01;
-		print Destination 'n -t ', $n_duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
-		print Destination 'n -t ', $n_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-
-		$n_duration = $n_duration + 0.005;
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "Sending Data packets" -L ""', "\n";
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c tan -o DarkOliveGreen -i tan -I DarkOliveGreen', "\n";
-
-		print Destination '+ -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination '- -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination 'h -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
-		print Destination 'r -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
-		$n_duration = $n_duration + 0.01;
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c black -o tan -i black -I tan', "\n";
-		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L "" ', "\n";
-		$i++;
-
-		$n_duration = $n_duration + 0.01;
-		print Destination 'n -t ', $n_duration, ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
-		print Destination 'n -t ', $n_duration, ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
-		print Destination '+ -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		print Destination '- -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		print Destination 'h -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		print Destination 'r -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
-		$duration = $n_duration + 0.01;
-		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
-		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
-		$i++;
-
-		$line = <Source>;
-		$temp = $duration;
-
-		}
-
-	else {
-		$line = <Source>;
-		$temp = @fields[1];
-	     }
-}
-
-close Source;
-close Destination;
-close Nam;
+# Script parses the trace file and using the base nam
+# file, it generates a nam file that sets colors to
+# nodes and data packets depending on their state.
+# When a node is doing carrier sense, it turns red.
+# When a node is sending RTS packets, it turns purple.
+# RTS packets are purple broadcas packets.
+# When a node is sending CTS packets, it turns green.
+# CTS packets are green broadcast packets.
+# When a node is sending data packets, it turns tan.
+# Data packets are tan in color.
+# When a node is sending ACK packets, it turns orange.
+# ACK packets are orange in color.
+sub usage {
+	print STDERR "usage: $0 <Base trace file> <Base nam trace file> <output nam trace file>n";
+	exit;
+}
+
+#@ARGV[0] - source trace file
+#@ARGV[1] - source nam trace file
+#@ARGV[2] - output nam trace file
+
+open (Nam, $ARGV[1]) or die "Cannot open $ARGV[1] : $!\n";
+open (Source, $ARGV[0]) or die "Cannot open $ARGV[0] : $!\n";
+open (Destination, ">$ARGV[2]") or die "Cannot open $ARGV[2]: $!\n";
+
+
+$line = <Nam>;
+$tp =0;
+while (($line) && ($tp ==0)) { 
+	if ($line =~ /-i 3 -n green/) {
+		print Destination $line;
+		print Destination 'v -t 0.0 -e set_rate_ext 0.550ms 1', "\n";
+		print Destination 'v -t 0.0 -e sim_annotation 0.0 1 In a Wireless network topology,when not all nodes are within each other\'s range, ',"\n";
+		print Destination 'v -t 0.01 -e sim_annotation 0.001 2 carrier sense only provides information about collisions at the sender,not at ', "\n";
+		print Destination 'v -t 0.015 -e sim_annotation 0.002 3 the receiver. This leads to problems like hidden terminal where two sender ', "\n";
+		print Destination 'v -t 0.02 -e sim_annotation 0.003 4 nodes out of range of each other transmit packets at the same time, ', "\n";
+		print Destination 'v -t 0.025 -e sim_annotation 0.004 5 to the same receiver, resulting in  collisions at the receiver. To solve ', "\n";
+ 		print Destination 'v -t 0.03 -e sim_annotation 0.005 6 such problems, control packets, RTS & CTS are used. When a node wants to ', "\n";
+		print Destination 'v -t 0.035 -e sim_annotation 0.006 7 transmit packets, it first sends a RTS packet to the receiver.All nodes within ', "\n";
+		print Destination 'v -t 0.04 -e sim_annotation 0.007 8 the sender\'s range receive this RTS packet. Every node hearing this RTS packet ', "\n";
+		print Destination 'v -t 0.045 -e sim_annotation 0.008 9 will defer transmission. If receiver is not receiving data from any other node, ', "\n";
+		print Destination 'v -t 0.05 -e sim_annotation 0.009 10 it responds with a CTS packet.This packet is again received by every node ', "\n";
+		print Destination 'v -t 0.055 -e sim_annotation 0.01 11 within range of receiver. So all nodes in this range defer transmission. ', "\n";
+		print Destination 'v -t 0.06 -e sim_annotation 0.02 12 Sender node sends data packet after receiving CTS. If sender node does not ', "\n";
+		print Destination 'v -t 0.065 -e sim_annotation 0.03 13 hear the CTS, it will time-out and schedule retransmission of RTS. On ', "\n";
+		print Destination 'v -t 0.07 -e sim_annotation 0.04 14 receiving data packet, receiver sends an ACK to sender.  ', "\n";
+		$tp = 1;
+	}
+	else
+	{
+		print Destination $line;
+		$line = <Nam>;
+	}
+}
+
+print Destination 'v -t 0.100 -e sim_annotation 0.100 18 COLOR LEGEND : ', "\n";
+print Destination 'v -t 0.110 -e sim_annotation 0.110 19 RTS packets : Purple color. Node turns purple  while sending an RTS packet ', "\n";
+print Destination 'v -t 0.120 -e sim_annotation 0.120 20 CTS packets : Green color . Node turns  green while sending CTS packets ', "\n";
+print Destination 'v -t 0.130 -e sim_annotation 0.130 21 Data packets : Tan color . Node turns tan while sending data packets ', "\n";
+print Destination 'v -t 0.140 -e sim_annotation 0.140 22 ACK packets : Orange color. Node turns  orange while sending ACK packets ', "\n";
+$line = <Source>;
+@fields = split ' ', $line;
+my $temp = @fields[1];
+my $i = 23;
+my $t = 1;
+my $dw = 0;
+my $num_mov = 0;
+my $come = 0;
+my $once = 0;
+
+while($line) {
+	@fields = split ' ', $line;
+	@fields[1] = $temp + 0.005;
+	# This generates movement of node in name file.
+	if ($line =~ /^M/)
+	{
+		@fields[3] =~ m/(\d+\.\d+)/;
+		@fields[3] = $1;
+		@fields[4] =~ m/(\d+\.\d+)/;
+		@fields[4] = $1;
+		@fields[6] =~ m/(\d+\.\d+)/;
+		@fields[6] = $1;
+		$t = (@fields[6] - @fields[3])/@fields[8];
+		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -x ', @fields[3], ' -y ', @fields[4], ' -U ',@fields[8], ' -V 0.00 -T ', $t,"\n";
+		$num_mov ++;
+		if($num_mov == 1)
+			{
+			print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' NODE MOVES : Sender nodes can hear both RTS and CTS ', "\n";
+		$i++;
+			}
+		elsif ($num_mov == 2)
+			{
+			print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' NODE MOVES : Sender nodes can hear CTS but not RTS', "\n";
+		$i++;
+			}
+		$line = <Source>;
+		$temp = @fields[1];
+	}
+	elsif( # This parses the trace file for RTS packets before node moves.
+		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /RTS/) && (@fields[2] !~ /1/) && ($num_mov <= 1)
+	   ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$other_node = 0;
+		if (@fields[2] == 0)
+		{
+			$other_node = 2;
+		}
+		if ($come == 0)
+		{
+		$come = 1;
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' CASE 1 : NO CONTENTION. ', "\n";
+		$i++;
+		@fields[1] = @fields[1] + 0.00005;
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' Only one node sends data, it does a simple RTS-CTS_DATA-ACK exchange ', "\n";
+		$i++;
+		@fields[1] = @fields[1] + 0.00005; 
+		print Destination 'n -t ', @fields[1], ' -s 0 -S COLOR -c red -o black -i red -I black', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
+		$duration = @fields[1] + 0.005;
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c purple -o red -i purple -I red', "\n";
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
+		print Destination '+ -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination '- -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'h -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'r -t ', $duration, ' -s ', @fields[2], ' -d -1 p message -e 500 -a 7', "\n";
+		$new_duration = $duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o purple -i black -I purple', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
+		$new_duration = $new_duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
+		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
+		print Destination '+ -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination '- -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'h -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'r -t ', $new_duration, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		$new_duration = $new_duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
+		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$new_duration = $new_duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c tan -o black -i tan -I black', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending Data Packet" -L ""', "\n";
+		print Destination '+ -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination '- -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination 'h -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination 'r -t ', $new_duration, ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		$new_duration = $new_duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o tan -i black -I tan', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
+		$new_duration = $new_duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
+		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
+		print Destination '+ -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination '- -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'h -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'r -t ', $new_duration, ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		$new_duration = $new_duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s 1 -S COLOR -c black -o orange -i black -I orange', "\n";
+		print Destination 'n -t ', $new_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		print Destination 'v -t ', $new_duration, ' -e sim_annotation ', $new_duration, ' ', $i, ' CASE 2 : BACKOFF DUE TO RTS', "\n"; 
+		$i++;
+		$new_duration = $new_duration + 0.005;
+		print Destination 'v -t ', $new_duration , ' -e sim_annotation ', $new_duration, ' ' , $i, ' Nodes are in RTS range of each other but not in CTS range of the receiver ', "\n";
+		$i++;
+		$new_duration = $new_duration + 0.005;
+		print Destination 'v -t ', $new_duration , ' -e sim_annotation ', $new_duration, ' ', $i, ' Node 0 want to send data to Node 1 at the same time that Node 2 wants to send data to Node 0 ', "\n";
+		$i++;
+		$new_duration = $new_duration + 0.005;
+		print Destination 'v -t ', $new_duration, ' -e sim_annotation ', $new_duration, ' ', $i, ' thus Node 2 backsoff when it hears the RTS from Node 0', "\n";
+		$i ++;
+		$temp = $new_duration;
+		@fields[1] = $new_duration + 0.01;
+		}
+		if($num_mov == 1)
+		{
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' CASE 3 : BACKOFF AGAIN DUE TO RTS', "\n";
+		$i++;
+		$new_duration = @fields[1] + 0.00005;
+		print Destination 'v -t ', $new_duration, ' -e sim_annotation ', $new_duration, ' ', $i, ' All nodes are in the RTS and CTS range of each other', "\n";
+		$i++;
+		$new_duration = $new_duration + 0.00005;
+		print Destination 'v -t ', $new_duration, ' -e sim_annotation  ', $new_duration, ' ' , $i, ' Nodes 0 and 2 are in range of each other and hence can hear the RTS packet of the other node after hearing RTS packet node backs off', "\n";
+		$i ++;
+		@fields[1] = $new_duration + 0.01;
+		}
+		print Destination 'n -t ', @fields[1], ' -s 0 -S COLOR -c red -o black -i red -I black', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 2 -S COLOR -c red -o black -i red -I black', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 2 -S DLABEL -l "Carrier sense" -L ""', "\n";
+		$duration = @fields[1] + 0.005;
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c purple -o red -i purple -I red', "\n";
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
+		print Destination '+ -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination '- -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'h -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'r -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+
+		$new_duration = $duration + 0.01;
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o purple -i black -I purple', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
+
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c DarkOliveGreen -o red -i DarkOliveGreen -I red', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "Data Waiting" -L ""', "\n";
+		$i ++;
+		$line = <Source>;
+		$temp = $new_duration;
+		}
+	elsif( # This parses trace file for RTS packets after node moves
+		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /RTS/) && (@fields[2] !~ /1/) && ($num_mov > 1)
+	  ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$other_node = 0;
+		if (@fields[2] == 0)
+		{
+			$other_node = 2;
+		}
+		if ($once == 0) {
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation  ', @fields[1], ' ' , $i, ' CASE 4 : BACKOFF DUE TO CTS ', "\n";
+		$i++;
+		@fields[1] = @fields[1] + 0.005;
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' Senders are out of range of RTS of each other but are in  range of CTS of receiver', "\n";
+		$i ++;
+		@fields[1] = @fields[1] + 0.005;
+		print Destination 'v -t ', @fields[1], ' -e sim_annotation ', @fields[1], ' ', $i, ' Node 0 sends RTS which Node 2 does not hear but it hears the CTS sent by receiver and thus backsoff after hearing CTS, thus avoiding collision at the receiver', "\n";
+		$i ++;
+		@fields[1] = @fields[1] + 0.005;
+
+		$once ++;
+		}
+		if ($dw == 0) {
+			print Destination 'n -t ', @fields[1], ' -s 0 -S COLOR -c red -o black -i red -I black', "\n";
+			print Destination 'n -t ', @fields[1], ' -s 2 -S COLOR -c red -o black -i red -I black', "\n";
+			print Destination 'n -t ', @fields[1], ' -s 0 -S DLABEL -l "Carrier sense" -L ""', "\n";
+			print Destination 'n -t ', @fields[1], ' -s 2 -S DLABEL -l "Carrier sense" -L ""', "\n";
+		}
+		if($dw == 1) {
+			print Destination 'n -t ', @fields[1],' -s ', @fields[2],' -S COLOR -c red -o black -i red -I black', "\n";
+			print Destination 'n -t ', @fields[1],' -s ', @fields[2],' -S DLABEL -l "Carrier sense" -L ""', "\n";
+		}
+
+		$duration = @fields[1] + 0.005;
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c purple -o red -i purple -I red', "\n";
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
+		print Destination '+ -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination '- -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'h -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'r -t ', $duration, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 7', "\n";
+		$new_duration = $duration + 0.005;
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S COLOR -c black -o purple -i black -I purple', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L ""', "\n";
+		$temp = $new_duration;
+		if ($t == 1) {
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c purple -o red -i purple -I red', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
+		print Destination '+ -t ', $new_duration, ' -s ', $other_node, ' -d  -1 -p message -e 500 -a 7', "\n";
+		print Destination '- -t ', $new_duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'h -t ', $new_duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'r -t ', $new_duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		$final_duration = $new_duration + 0.005;
+		print Destination 'n -t ', $final_duration, ' -s ', $other_node, ' -S COLOR -c black -o purple -i black -I purple', "\n";
+		print Destination 'n -t ', $final_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L ""', "\n";
+		$t++;
+		$temp = $final_duration;
+		}
+		$line = <Source>;
+	    }
+	elsif( # This parses trace file for CTS packets after node moves
+		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /CTS/) && (@fields[2] !~ /0/) && (@fields[2] !~ /2/) && ($num_mov >= 1)
+	     ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$jitter = @fields[1] + 0.01;
+		print Destination 'n -t ', $jitter, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
+		print Destination 'n -t ', $jitter, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
+		print Destination '+ -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination '- -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'h -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'r -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		$duration = $jitter + 0.01;
+		print Destination 'n -t ', $duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
+		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$i++;
+		$line = <Source>;
+		$temp = $duration;
+		}
+	elsif( # This parses trace file for CTS packets after node moves
+		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /CTS/) && (@fields[2] !~ /0/) && (@fields[2] !~ /2/) && ($num_mov == 0)
+	     ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$jitter = @fields[1] + 0.01;
+
+		print Destination 'n -t ', $jitter, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
+		print Destination 'n -t ', $jitter, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
+		print Destination '+ -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination '- -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'h -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'r -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		$duration = $jitter + 0.01;
+		print Destination 'n -t ', $duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
+		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$i++;
+		$line = <Source>;
+		$temp = $duration;
+		}
+	elsif( # This parses trace file for data packets
+		($line =~ /s/) && ($line =~ /MAC/) && ($line =~ /message/) && (@fields[2] !~ /1/)
+	     ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$other_node = 0;
+		if(@fields[2] == 0) {
+			$other_node = 2;
+		}
+		@fields[1] = @fields[1] +0.01;
+		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -S DLABEL -l "Sending Data packets" -L ""', "\n";
+		print Destination 'n -t ', @fields[1], ' -s ', @fields[2], ' -S COLOR -c tan -o black -i tan -I black', "\n";
+		if(($num_mov > 1) && ($dw == 0)) {
+			print Destination 'n -t ', @fields[1], ' -s ', $other_node, ' -S COLOR -c DarkOliveGreen -o black -i DarkOliveGreen -I black', "\n";
+			print Destination 'n -t ', @fields[1], ' -s ', $other_node, ' -S DLABEL -l "Data waiting" -L ""', "\n";
+		}
+		print Destination '+ -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination '- -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination 'h -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination 'r -t ', @fields[1], ' -s ', @fields[2], ' -d 1 -p message -e 2500 -a 6', "\n";
+		$duration = @fields[1] + 0.01;
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S COLOR -c black -o tan -i black -I tan', "\n";
+		print Destination 'n -t ', $duration, ' -s ', @fields[2], ' -S DLABEL -l "" -L "" ', "\n";
+		$i++;
+		$line = <Source>;
+		$temp = $duration;
+		}
+	elsif( # This parses trace file for ACK packets
+		($line =~ /r/) && ($line =~ /MAC/) && ($line =~ /ACK/) && (@fields[2] !~ /1/) && ($num_mov > 1)
+	     ) {
+		$dw ++;
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		print Destination 'n -t ', @fields[1], ' -s 1 -S DLABEL -l "Sending ACK packets" -L ""', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
+		print Destination '+ -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination '- -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'h -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'r -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		$duration = @fields[1] + 0.01;
+		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
+		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$i++;
+		$line = <Source>;
+		$temp = $duration;
+		}
+	elsif( # This parses trace file for ACK packets.
+		($line =~ /r/) && ($line =~ /MAC/) && ($line =~ /ACK/) && (@fields[2] !~ /1/) && ($num_mov == 0)
+	     ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$other_node = 0;
+		if(@fields[2] == 0) {
+			$other_node = 2;
+		}
+		print Destination 'n -t ', @fields[1], ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
+		print Destination '+ -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination '- -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'h -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'r -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		$duration = @fields[1] + 0.01;
+		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
+		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$i++;
+
+
+		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S COLOR -c purple -o DarkOliveGreen -i purple -I DarkOliveGreen', "\n";
+		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
+		print Destination '+ -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination '- -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'h -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'r -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		$new_duration = $duration + 0.005;
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c black -o purple -i black -I purple', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L ""', "\n";
+		$i ++;
+
+		$jitter = $new_duration + 0.01;
+		print Destination 'n -t ', $jitter, ' -s ', @fields[2], ' -S DLABEL -l "Sending CTS packets" -L ""', "\n";
+		print Destination 'n -t ', $jitter, ' -s ', @fields[2], ' -S COLOR -c green -o black -i green -I black', "\n";
+		print Destination '+ -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
+		print Destination '- -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'h -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'r -t ', $jitter, ' -s ', @fields[2], ' -d -1 -p message -e 500 -a 3', "\n";
+		$n_duration = $jitter + 0.01;
+		print Destination 'n -t ', $n_duration, ' -s ', @fields[2], ' -S COLOR -c black -o green -i black -I green', "\n";
+		print Destination 'n -t ', $n_duration, ' -s ', @fields[2],' -S DLABEL -l "" -L ""', "\n";
+		$i++;
+
+		$n_duration = $n_duration + 0.005;
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "Sending Data packets" -L ""', "\n";
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c tan -o DarkOliveGreen -i tan -I DarkOliveGreen', "\n";
+
+		print Destination '+ -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
+		print Destination '- -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
+		print Destination 'h -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
+		print Destination 'r -t ', $n_duration, ' -s ', $other_node, ' -d ', @fields[2], ' -p message -e 2500 -a 6', "\n";
+		$n_duration = $n_duration + 0.01;
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c black -o tan -i black -I tan', "\n";
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L "" ', "\n";
+		$i++;
+
+		$n_duration = $n_duration + 0.01;
+		print Destination 'n -t ', $n_duration, ' -s ', @fields[2],' -S DLABEL -l "Sending ACK packet" -L ""', "\n";
+		print Destination 'n -t ', $n_duration, ' -s ', @fields[2],' -S COLOR -c orange -o black -i orange -I black', "\n";
+		print Destination '+ -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		print Destination '- -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		print Destination 'h -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		print Destination 'r -t ', $n_duration, ' -s ', @fields[2],' -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		$duration = $n_duration + 0.01;
+		print Destination 'n -t ', $duration, ' -s ', @fields[2],'  -S COLOR -c black -o orange -i black -I orange', "\n";
+		print Destination 'n -t ', $duration, ' -s ', @fields[2],' -S DLABEL -l "" -L ""', "\n";
+		$i++;
+
+
+
+		$line = <Source>;
+		$temp = $duration;
+
+		}
+	elsif(
+		($line =~ /r/) && ($line =~ /MAC/) && ($line =~ /ACK/) && (@fields[2] !~ /1/) && ($num_mov == 1)
+	     ) {
+		@fields[2] =~ m/(\d)/;
+		@fields[2] = $1;
+		$other_node = 0;
+		if(@fields[2] == 0) {
+			$other_node = 2;
+		}
+		print Destination 'n -t ', @fields[1], ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
+		print Destination 'n -t ', @fields[1], ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
+		print Destination '+ -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination '- -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'h -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		print Destination 'r -t ', @fields[1], ' -s 1 -d ', @fields[2], ' -p message -e 500 -a 2', "\n";
+		$duration = @fields[1] + 0.01;
+		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
+		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$i++;
+
+		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S COLOR -c purple -o DarkOliveGreen -i purple -I DarkOliveGreen', "\n";
+		print Destination 'n -t ', $duration, ' -s ', $other_node, ' -S DLABEL -l "Sending RTS packet" -L ""', "\n";
+
+		print Destination '+ -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination '- -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'h -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+		print Destination 'r -t ', $duration, ' -s ', $other_node, ' -d -1 -p message -e 500 -a 7', "\n";
+
+		$new_duration = $duration + 0.005;
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S COLOR -c black -o purple -i black -I purple', "\n";
+		print Destination 'n -t ', $new_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L ""', "\n";
+		$i ++;
+
+		$jitter = $new_duration + 0.01;
+		print Destination 'n -t ', $jitter, ' -s 1 -S DLABEL -l "Sending CTS packets" -L ""', "\n";
+		print Destination 'n -t ', $jitter, ' -s 1 -S COLOR -c green -o black -i green -I black', "\n";
+		print Destination '+ -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination '- -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'h -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		print Destination 'r -t ', $jitter, ' -s 1 -d -1 -p message -e 500 -a 3', "\n";
+		$n_duration = $jitter + 0.01;
+		print Destination 'n -t ', $n_duration, ' -s 1 -S COLOR -c black -o green -i black -I green', "\n";
+		print Destination 'n -t ', $n_duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+
+		$n_duration = $n_duration + 0.005;
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "Sending Data packets" -L ""', "\n";
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c tan -o DarkOliveGreen -i tan -I DarkOliveGreen', "\n";
+
+		print Destination '+ -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination '- -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination 'h -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
+		print Destination 'r -t ', $n_duration, ' -s ', $other_node, ' -d 1 -p message -e 2500 -a 6', "\n";
+		$n_duration = $n_duration + 0.01;
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S COLOR -c black -o tan -i black -I tan', "\n";
+		print Destination 'n -t ', $n_duration, ' -s ', $other_node, ' -S DLABEL -l "" -L "" ', "\n";
+		$i++;
+
+		$n_duration = $n_duration + 0.01;
+		print Destination 'n -t ', $n_duration, ' -s 1 -S DLABEL -l "Sending ACK packet" -L ""', "\n";
+		print Destination 'n -t ', $n_duration, ' -s 1 -S COLOR -c orange -o black -i orange -I black', "\n";
+		print Destination '+ -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		print Destination '- -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		print Destination 'h -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		print Destination 'r -t ', $n_duration, ' -s 1 -d ', $other_node, ' -p message -e 500 -a 2', "\n";
+		$duration = $n_duration + 0.01;
+		print Destination 'n -t ', $duration, ' -s 1  -S COLOR -c black -o orange -i black -I orange', "\n";
+		print Destination 'n -t ', $duration, ' -s 1 -S DLABEL -l "" -L ""', "\n";
+		$i++;
+
+		$line = <Source>;
+		$temp = $duration;
+
+		}
+
+	else {
+		$line = <Source>;
+		$temp = @fields[1];
+	     }
+}
+
+close Source;
+close Destination;
+close Nam;
--- tcl/ex/diffserv/ds-cbr-srtcm.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-srtcm.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,164 +1,164 @@
-#--------------------------------------------------------------------------------
-# cbr-srtcm.tcl
-# Author: Jeremy Ethridge.
-# Dates: July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the srTCM policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0     2000
-set ebs0     3000 
-set rate0 3000000
-set cir1  1000000
-set cbs1     2000
-set ebs1     6000
-set rate1 3000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 3
-$qE1C addPolicyEntry [$s1 id] [$dest id] srTCM 10 $cir0 $cbs0 $ebs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] srTCM 10 $cir1 $cbs1 $ebs1
-$qE1C addPolicerEntry srTCM 10 11 12
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 12 0 2
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-$qE1C configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 3
-$qE2C addPolicyEntry [$dest id] [$s1 id] srTCM 10 $cir0 $cbs0 $ebs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] srTCM 10 $cir1 $cbs1 $ebs1
-$qE2C addPolicerEntry srTCM 10 11 12
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 12 0 2
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-$qE2C configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 3
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 12 0 2
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-$qCE1 configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 1
-$qCE2 setNumPrec 3
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 12 0 2
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 0 2  5 10 0.20
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-srtcm.tcl
+# Author: Jeremy Ethridge.
+# Dates: July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the srTCM policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0     2000
+set ebs0     3000 
+set rate0 3000000
+set cir1  1000000
+set cbs1     2000
+set ebs1     6000
+set rate1 3000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 3
+$qE1C addPolicyEntry [$s1 id] [$dest id] srTCM 10 $cir0 $cbs0 $ebs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] srTCM 10 $cir1 $cbs1 $ebs1
+$qE1C addPolicerEntry srTCM 10 11 12
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 12 0 2
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+$qE1C configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 3
+$qE2C addPolicyEntry [$dest id] [$s1 id] srTCM 10 $cir0 $cbs0 $ebs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] srTCM 10 $cir1 $cbs1 $ebs1
+$qE2C addPolicerEntry srTCM 10 11 12
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 12 0 2
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+$qE2C configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 3
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 12 0 2
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+$qCE1 configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 1
+$qCE2 setNumPrec 3
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 12 0 2
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 0 2  5 10 0.20
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-tb-PRI.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-tb-PRI.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,170 +1,170 @@
-#--------------------------------------------------------------------------------
-# cbr-tb.tcl
-# Author: Jeremy Ethridge.
-# Dates: June 29-July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0    10000
-set rate0 4000000
-set cir1  1000000
-set cbs1    10000
-set rate1 4000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 2
-$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
-$qE1C addPolicerEntry TokenBucket 10 11
-$qE1C addPolicerEntry TokenBucket 20 21
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 20 0 0
-$qE1C addPHBEntry 21 0 1
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 2
-$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
-$qE2C addPolicerEntry TokenBucket 10 11
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 20 0 0
-$qE2C addPHBEntry 21 0 1
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 2
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 20 0 0
-$qCE1 addPHBEntry 21 0 1
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 setSchedularMode PRI
-$qCE2 addQueueRate 0 3000000
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 2
-$qCE2 setNumPrec 2
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 20 1 0
-$qCE2 addPHBEntry 21 1 1
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 1 0 20 40 0.02
-$qCE2 configQ 1 1 10 20 0.10
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-tb.tcl
+# Author: Jeremy Ethridge.
+# Dates: June 29-July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0    10000
+set rate0 4000000
+set cir1  1000000
+set cbs1    10000
+set rate1 4000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 2
+$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
+$qE1C addPolicerEntry TokenBucket 10 11
+$qE1C addPolicerEntry TokenBucket 20 21
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 20 0 0
+$qE1C addPHBEntry 21 0 1
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 2
+$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
+$qE2C addPolicerEntry TokenBucket 10 11
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 20 0 0
+$qE2C addPHBEntry 21 0 1
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 2
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 20 0 0
+$qCE1 addPHBEntry 21 0 1
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 setSchedularMode PRI
+$qCE2 addQueueRate 0 3000000
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 2
+$qCE2 setNumPrec 2
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 20 1 0
+$qCE2 addPHBEntry 21 1 1
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 1 0 20 40 0.02
+$qCE2 configQ 1 1 10 20 0.10
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-tb-RR.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-tb-RR.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,168 +1,168 @@
-#--------------------------------------------------------------------------------
-# cbr-tb.tcl
-# Author: Jeremy Ethridge.
-# Dates: June 29-July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0    10000
-set rate0 4000000
-set cir1  1000000
-set cbs1    10000
-set rate1 4000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 2
-$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
-$qE1C addPolicerEntry TokenBucket 10 11
-$qE1C addPolicerEntry TokenBucket 20 21
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 20 0 0
-$qE1C addPHBEntry 21 0 1
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 2
-$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
-$qE2C addPolicerEntry TokenBucket 10 11
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 20 0 0
-$qE2C addPHBEntry 21 0 1
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 2
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 20 0 0
-$qCE1 addPHBEntry 21 0 1
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 2
-$qCE2 setNumPrec 2
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 20 1 0
-$qCE2 addPHBEntry 21 1 1
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 1 0 20 40 0.02
-$qCE2 configQ 1 1 10 20 0.10
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-tb.tcl
+# Author: Jeremy Ethridge.
+# Dates: June 29-July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0    10000
+set rate0 4000000
+set cir1  1000000
+set cbs1    10000
+set rate1 4000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 2
+$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
+$qE1C addPolicerEntry TokenBucket 10 11
+$qE1C addPolicerEntry TokenBucket 20 21
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 20 0 0
+$qE1C addPHBEntry 21 0 1
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 2
+$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
+$qE2C addPolicerEntry TokenBucket 10 11
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 20 0 0
+$qE2C addPHBEntry 21 0 1
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 2
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 20 0 0
+$qCE1 addPHBEntry 21 0 1
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 2
+$qCE2 setNumPrec 2
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 20 1 0
+$qCE2 addPHBEntry 21 1 1
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 1 0 20 40 0.02
+$qCE2 configQ 1 1 10 20 0.10
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-tb.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-tb.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,154 +1,154 @@
-#--------------------------------------------------------------------------------
-# cbr-tb.tcl
-# Author: Jeremy Ethridge.
-# Dates: June 29-July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0     3000
-set rate0 2000000
-set cir1  1000000
-set cbs1    10000
-set rate1 3000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 2
-$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 10 $cir0 $cbs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
-$qE1C addPolicerEntry TokenBucket 10 11
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 2
-$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 10 $cir0 $cbs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
-$qE2C addPolicerEntry TokenBucket 10 11
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 2
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 1
-$qCE2 setNumPrec 2
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-tb.tcl
+# Author: Jeremy Ethridge.
+# Dates: June 29-July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0     3000
+set rate0 2000000
+set cir1  1000000
+set cbs1    10000
+set rate1 3000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 2
+$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 10 $cir0 $cbs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
+$qE1C addPolicerEntry TokenBucket 10 11
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 2
+$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 10 $cir0 $cbs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
+$qE2C addPolicerEntry TokenBucket 10 11
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 2
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 1
+$qCE2 setNumPrec 2
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-tb-WIRR.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-tb-WIRR.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,171 +1,171 @@
-#--------------------------------------------------------------------------------
-# cbr-tb.tcl
-# Author: Jeremy Ethridge.
-# Dates: June 29-July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0    10000
-set rate0 4000000
-set cir1  1000000
-set cbs1    10000
-set rate1 4000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 2
-$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
-$qE1C addPolicerEntry TokenBucket 10 11
-$qE1C addPolicerEntry TokenBucket 20 21
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 20 0 0
-$qE1C addPHBEntry 21 0 1
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 2
-$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
-$qE2C addPolicerEntry TokenBucket 10 11
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 20 0 0
-$qE2C addPHBEntry 21 0 1
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 2
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 20 0 0
-$qCE1 addPHBEntry 21 0 1
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 setSchedularMode WIRR
-$qCE2 addQueueWeights 0 3
-$qCE2 addQueueWeights 1 7
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 2
-$qCE2 setNumPrec 2
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 20 1 0
-$qCE2 addPHBEntry 21 1 1
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 1 0 20 40 0.02
-$qCE2 configQ 1 1 10 20 0.10
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-tb.tcl
+# Author: Jeremy Ethridge.
+# Dates: June 29-July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0    10000
+set rate0 4000000
+set cir1  1000000
+set cbs1    10000
+set rate1 4000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 2
+$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
+$qE1C addPolicerEntry TokenBucket 10 11
+$qE1C addPolicerEntry TokenBucket 20 21
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 20 0 0
+$qE1C addPHBEntry 21 0 1
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 2
+$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
+$qE2C addPolicerEntry TokenBucket 10 11
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 20 0 0
+$qE2C addPHBEntry 21 0 1
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 2
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 20 0 0
+$qCE1 addPHBEntry 21 0 1
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 setSchedularMode WIRR
+$qCE2 addQueueWeights 0 3
+$qCE2 addQueueWeights 1 7
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 2
+$qCE2 setNumPrec 2
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 20 1 0
+$qCE2 addPHBEntry 21 1 1
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 1 0 20 40 0.02
+$qCE2 configQ 1 1 10 20 0.10
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-tb-WRR.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-tb-WRR.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,171 +1,171 @@
-#--------------------------------------------------------------------------------
-# cbr-tb.tcl
-# Author: Jeremy Ethridge.
-# Dates: June 29-July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0    10000
-set rate0 4000000
-set cir1  1000000
-set cbs1    10000
-set rate1 4000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 2
-$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
-$qE1C addPolicerEntry TokenBucket 10 11
-$qE1C addPolicerEntry TokenBucket 20 21
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 20 0 0
-$qE1C addPHBEntry 21 0 1
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 2
-$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
-$qE2C addPolicerEntry TokenBucket 10 11
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 20 0 0
-$qE2C addPHBEntry 21 0 1
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 2
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 20 0 0
-$qCE1 addPHBEntry 21 0 1
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 setSchedularMode WRR
-$qCE2 addQueueWeights 0 3
-$qCE2 addQueueWeights 1 7
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 2
-$qCE2 setNumPrec 2
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 20 1 0
-$qCE2 addPHBEntry 21 1 1
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 1 0 20 40 0.02
-$qCE2 configQ 1 1 10 20 0.10
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-tb.tcl
+# Author: Jeremy Ethridge.
+# Dates: June 29-July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the Token Bucket policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0    10000
+set rate0 4000000
+set cir1  1000000
+set cbs1    10000
+set rate1 4000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 2
+$qE1C addPolicyEntry [$s1 id] [$dest id] TokenBucket 20 $cir0 $cbs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] TokenBucket 10 $cir1 $cbs1
+$qE1C addPolicerEntry TokenBucket 10 11
+$qE1C addPolicerEntry TokenBucket 20 21
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 20 0 0
+$qE1C addPHBEntry 21 0 1
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 2
+$qE2C addPolicyEntry [$dest id] [$s1 id] TokenBucket 20 $cir0 $cbs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] TokenBucket 10 $cir1 $cbs1
+$qE2C addPolicerEntry TokenBucket 10 11
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 20 0 0
+$qE2C addPHBEntry 21 0 1
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 2
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 20 0 0
+$qCE1 addPHBEntry 21 0 1
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 setSchedularMode WRR
+$qCE2 addQueueWeights 0 3
+$qCE2 addQueueWeights 1 7
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 2
+$qCE2 setNumPrec 2
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 20 1 0
+$qCE2 addPHBEntry 21 1 1
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 1 0 20 40 0.02
+$qCE2 configQ 1 1 10 20 0.10
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-trtcm.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-trtcm.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,166 +1,166 @@
-#--------------------------------------------------------------------------------
-# cbr-trtcm.tcl
-# Author: Jeremy Ethridge.
-# Dates: July 6, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the trTCM policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0  1000000
-set cbs0     2000
-set pir0  2000000
-set pbs0     3000 
-set rate0 3000000
-set cir1  1000000
-set cbs1     2000
-set pir1  1000000
-set pbs1     3000
-set rate1 3000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 3
-$qE1C addPolicyEntry [$s1 id] [$dest id] trTCM 10 $cir0 $cbs0 $pir0 $pbs0
-$qE1C addPolicyEntry [$s2 id] [$dest id] trTCM 10 $cir1 $cbs1 $pir1 $pbs1
-$qE1C addPolicerEntry trTCM 10 11 12
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 12 0 2
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-$qE1C configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 3
-$qE2C addPolicyEntry [$dest id] [$s1 id] trTCM 10 $cir0 $cbs0 $pir0 $pbs0
-$qE2C addPolicyEntry [$dest id] [$s2 id] trTCM 10 $cir1 $cbs1 $pir1 $pbs1
-$qE2C addPolicerEntry trTCM 10 11 12
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 12 0 2
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-$qE2C configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 3
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 12 0 2
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-$qCE1 configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 1
-$qCE2 setNumPrec 3
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 12 0 2
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 0 2  5 10 0.20
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-trtcm.tcl
+# Author: Jeremy Ethridge.
+# Dates: July 6, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the trTCM policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0  1000000
+set cbs0     2000
+set pir0  2000000
+set pbs0     3000 
+set rate0 3000000
+set cir1  1000000
+set cbs1     2000
+set pir1  1000000
+set pbs1     3000
+set rate1 3000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 3
+$qE1C addPolicyEntry [$s1 id] [$dest id] trTCM 10 $cir0 $cbs0 $pir0 $pbs0
+$qE1C addPolicyEntry [$s2 id] [$dest id] trTCM 10 $cir1 $cbs1 $pir1 $pbs1
+$qE1C addPolicerEntry trTCM 10 11 12
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 12 0 2
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+$qE1C configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 3
+$qE2C addPolicyEntry [$dest id] [$s1 id] trTCM 10 $cir0 $cbs0 $pir0 $pbs0
+$qE2C addPolicyEntry [$dest id] [$s2 id] trTCM 10 $cir1 $cbs1 $pir1 $pbs1
+$qE2C addPolicerEntry trTCM 10 11 12
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 12 0 2
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+$qE2C configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 3
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 12 0 2
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+$qCE1 configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 1
+$qCE2 setNumPrec 3
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 12 0 2
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 0 2  5 10 0.20
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/ds-cbr-TSW3CM.tcl	2000-11-01 23:30:49.000000000 -0500
+++ tcl/ex/diffserv/ds-cbr-TSW3CM.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,161 +1,161 @@
-#--------------------------------------------------------------------------------
-# cbr-TSW3CM.tcl
-# Author: Jeremy Ethridge.
-# Dates: June 15-July 5, 1999.
-# Notes: A DS-RED script that uses CBR traffic agents and the TSW3CM Policer.
-#
-#    ----
-#    |s1|-----------
-#    ----   10 Mb   \
-#            5 ms    \
-#                     \----           ------          ----           ------
-#                      |e1|-----------|core|----------|e2|-----------|dest|
-#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
-#                    /         5 ms            5 ms           5 ms
-#    ----           /
-#    |s2|-----------
-#    ----   10 Mb
-#            5 ms
-#
-#--------------------------------------------------------------------------------
-
-
-set ns [new Simulator]
-
-set cir0   100000
-set pir0   500000
-set rate0 4000000
-set cir1   400000
-set pir1  1000000
-set rate1 2000000
-
-set testTime 85.0
-set packetSize 1000
-
-
-# Set up the network topology shown at the top of this file:
-set s1 [$ns node]
-set s2 [$ns node]
-set e1 [$ns node]
-set core [$ns node]
-set e2 [$ns node]
-set dest [$ns node]
-
-$ns duplex-link $s1 $e1 10Mb 5ms DropTail
-$ns duplex-link $s2 $e1 10Mb 5ms DropTail
-
-$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
-$ns simplex-link $core $e1 10Mb 5ms dsRED/core
-
-$ns simplex-link $core $e2 5Mb 5ms dsRED/core
-$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
-
-$ns duplex-link $e2 $dest 10Mb 5ms DropTail
-
-
-$ns duplex-link-op $s1 $e1 orient down-right
-$ns duplex-link-op $s2 $e1 orient up-right
-$ns duplex-link-op $e1 $core orient right
-$ns duplex-link-op $core $e2 orient right
-$ns duplex-link-op $e2 $dest orient right
-
-
-set qE1C [[$ns link $e1 $core] queue]
-set qE2C [[$ns link $e2 $core] queue]
-set qCE1 [[$ns link $core $e1] queue]
-set qCE2 [[$ns link $core $e2] queue]
-
-# Set DS RED parameters from Edge1 to Core:
-$qE1C meanPktSize $packetSize
-$qE1C set numQueues_ 1
-$qE1C setNumPrec 3
-$qE1C addPolicyEntry [$s1 id] [$dest id] TSW3CM 10 $cir0 $pir0
-$qE1C addPolicyEntry [$s2 id] [$dest id] TSW3CM 10 $cir1 $pir1
-$qE1C addPolicerEntry TSW3CM 10 11 12
-$qE1C addPHBEntry 10 0 0
-$qE1C addPHBEntry 11 0 1
-$qE1C addPHBEntry 12 0 2
-$qE1C configQ 0 0 20 40 0.02
-$qE1C configQ 0 1 10 20 0.10
-$qE1C configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Edge2 to Core:
-$qE2C meanPktSize $packetSize
-$qE2C set numQueues_ 1
-$qE2C setNumPrec 3
-$qE2C addPolicyEntry [$dest id] [$s1 id] TSW3CM 10 $cir0 $pir0
-$qE2C addPolicyEntry [$dest id] [$s2 id] TSW3CM 10 $cir1 $pir1
-$qE2C addPolicerEntry TSW3CM 10 11 12
-$qE2C addPHBEntry 10 0 0
-$qE2C addPHBEntry 11 0 1
-$qE2C addPHBEntry 12 0 2
-$qE2C configQ 0 0 20 40 0.02
-$qE2C configQ 0 1 10 20 0.10
-$qE2C configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Core to Edge1:
-$qCE1 meanPktSize $packetSize
-$qCE1 set numQueues_ 1
-$qCE1 setNumPrec 3
-$qCE1 addPHBEntry 10 0 0
-$qCE1 addPHBEntry 11 0 1
-$qCE1 addPHBEntry 12 0 2
-$qCE1 configQ 0 0 20 40 0.02
-$qCE1 configQ 0 1 10 20 0.10
-$qCE1 configQ 0 2  5 10 0.20
-
-# Set DS RED parameters from Core to Edge2:
-$qCE2 meanPktSize $packetSize
-$qCE2 set numQueues_ 1
-$qCE2 setNumPrec 3
-$qCE2 addPHBEntry 10 0 0
-$qCE2 addPHBEntry 11 0 1
-$qCE2 addPHBEntry 12 0 2
-$qCE2 configQ 0 0 20 40 0.02
-$qCE2 configQ 0 1 10 20 0.10
-$qCE2 configQ 0 2  5 10 0.20
-
-
-# Set up one CBR connection between each source and the destination:
-set udp0 [new Agent/UDP]
-$ns attach-agent $s1 $udp0
-set cbr0 [new Application/Traffic/CBR]
-$cbr0 attach-agent $udp0
-$cbr0 set packet_size_ $packetSize
-$udp0 set packetSize_ $packetSize
-$cbr0 set rate_ $rate0
-set null0 [new Agent/Null]
-$ns attach-agent $dest $null0
-$ns connect $udp0 $null0
-
-set udp1 [new Agent/UDP]
-$ns attach-agent $s2 $udp1
-set cbr1 [new Application/Traffic/CBR]
-$cbr1 attach-agent $udp1
-$cbr1 set packet_size_ $packetSize
-$udp1 set packetSize_ $packetSize
-$cbr1 set rate_ $rate1
-set null1 [new Agent/Null]
-$ns attach-agent $dest $null1
-$ns connect $udp1 $null1
-
-
-proc finish {} {
-    global ns 
-    exit 0
-}
-
-$qE1C printPolicyTable
-$qE1C printPolicerTable
-
-$ns at 0.0 "$cbr0 start"
-$ns at 0.0 "$cbr1 start"
-$ns at 20.0 "$qCE2 printStats"
-$ns at 40.0 "$qCE2 printStats"
-$ns at 60.0 "$qCE2 printStats"
-$ns at 80.0 "$qCE2 printStats"
-$ns at $testTime "$cbr0 stop"
-$ns at $testTime "$cbr1 stop"
-$ns at [expr $testTime + 1.0] "finish"
-
-$ns run
+#--------------------------------------------------------------------------------
+# cbr-TSW3CM.tcl
+# Author: Jeremy Ethridge.
+# Dates: June 15-July 5, 1999.
+# Notes: A DS-RED script that uses CBR traffic agents and the TSW3CM Policer.
+#
+#    ----
+#    |s1|-----------
+#    ----   10 Mb   \
+#            5 ms    \
+#                     \----           ------          ----           ------
+#                      |e1|-----------|core|----------|e2|-----------|dest|
+#                     /----   10 Mb   ------   5 Mb   ----   10 Mb   ------
+#                    /         5 ms            5 ms           5 ms
+#    ----           /
+#    |s2|-----------
+#    ----   10 Mb
+#            5 ms
+#
+#--------------------------------------------------------------------------------
+
+
+set ns [new Simulator]
+
+set cir0   100000
+set pir0   500000
+set rate0 4000000
+set cir1   400000
+set pir1  1000000
+set rate1 2000000
+
+set testTime 85.0
+set packetSize 1000
+
+
+# Set up the network topology shown at the top of this file:
+set s1 [$ns node]
+set s2 [$ns node]
+set e1 [$ns node]
+set core [$ns node]
+set e2 [$ns node]
+set dest [$ns node]
+
+$ns duplex-link $s1 $e1 10Mb 5ms DropTail
+$ns duplex-link $s2 $e1 10Mb 5ms DropTail
+
+$ns simplex-link $e1 $core 10Mb 5ms dsRED/edge
+$ns simplex-link $core $e1 10Mb 5ms dsRED/core
+
+$ns simplex-link $core $e2 5Mb 5ms dsRED/core
+$ns simplex-link $e2 $core 5Mb 5ms dsRED/edge
+
+$ns duplex-link $e2 $dest 10Mb 5ms DropTail
+
+
+$ns duplex-link-op $s1 $e1 orient down-right
+$ns duplex-link-op $s2 $e1 orient up-right
+$ns duplex-link-op $e1 $core orient right
+$ns duplex-link-op $core $e2 orient right
+$ns duplex-link-op $e2 $dest orient right
+
+
+set qE1C [[$ns link $e1 $core] queue]
+set qE2C [[$ns link $e2 $core] queue]
+set qCE1 [[$ns link $core $e1] queue]
+set qCE2 [[$ns link $core $e2] queue]
+
+# Set DS RED parameters from Edge1 to Core:
+$qE1C meanPktSize $packetSize
+$qE1C set numQueues_ 1
+$qE1C setNumPrec 3
+$qE1C addPolicyEntry [$s1 id] [$dest id] TSW3CM 10 $cir0 $pir0
+$qE1C addPolicyEntry [$s2 id] [$dest id] TSW3CM 10 $cir1 $pir1
+$qE1C addPolicerEntry TSW3CM 10 11 12
+$qE1C addPHBEntry 10 0 0
+$qE1C addPHBEntry 11 0 1
+$qE1C addPHBEntry 12 0 2
+$qE1C configQ 0 0 20 40 0.02
+$qE1C configQ 0 1 10 20 0.10
+$qE1C configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Edge2 to Core:
+$qE2C meanPktSize $packetSize
+$qE2C set numQueues_ 1
+$qE2C setNumPrec 3
+$qE2C addPolicyEntry [$dest id] [$s1 id] TSW3CM 10 $cir0 $pir0
+$qE2C addPolicyEntry [$dest id] [$s2 id] TSW3CM 10 $cir1 $pir1
+$qE2C addPolicerEntry TSW3CM 10 11 12
+$qE2C addPHBEntry 10 0 0
+$qE2C addPHBEntry 11 0 1
+$qE2C addPHBEntry 12 0 2
+$qE2C configQ 0 0 20 40 0.02
+$qE2C configQ 0 1 10 20 0.10
+$qE2C configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Core to Edge1:
+$qCE1 meanPktSize $packetSize
+$qCE1 set numQueues_ 1
+$qCE1 setNumPrec 3
+$qCE1 addPHBEntry 10 0 0
+$qCE1 addPHBEntry 11 0 1
+$qCE1 addPHBEntry 12 0 2
+$qCE1 configQ 0 0 20 40 0.02
+$qCE1 configQ 0 1 10 20 0.10
+$qCE1 configQ 0 2  5 10 0.20
+
+# Set DS RED parameters from Core to Edge2:
+$qCE2 meanPktSize $packetSize
+$qCE2 set numQueues_ 1
+$qCE2 setNumPrec 3
+$qCE2 addPHBEntry 10 0 0
+$qCE2 addPHBEntry 11 0 1
+$qCE2 addPHBEntry 12 0 2
+$qCE2 configQ 0 0 20 40 0.02
+$qCE2 configQ 0 1 10 20 0.10
+$qCE2 configQ 0 2  5 10 0.20
+
+
+# Set up one CBR connection between each source and the destination:
+set udp0 [new Agent/UDP]
+$ns attach-agent $s1 $udp0
+set cbr0 [new Application/Traffic/CBR]
+$cbr0 attach-agent $udp0
+$cbr0 set packet_size_ $packetSize
+$udp0 set packetSize_ $packetSize
+$cbr0 set rate_ $rate0
+set null0 [new Agent/Null]
+$ns attach-agent $dest $null0
+$ns connect $udp0 $null0
+
+set udp1 [new Agent/UDP]
+$ns attach-agent $s2 $udp1
+set cbr1 [new Application/Traffic/CBR]
+$cbr1 attach-agent $udp1
+$cbr1 set packet_size_ $packetSize
+$udp1 set packetSize_ $packetSize
+$cbr1 set rate_ $rate1
+set null1 [new Agent/Null]
+$ns attach-agent $dest $null1
+$ns connect $udp1 $null1
+
+
+proc finish {} {
+    global ns 
+    exit 0
+}
+
+$qE1C printPolicyTable
+$qE1C printPolicerTable
+
+$ns at 0.0 "$cbr0 start"
+$ns at 0.0 "$cbr1 start"
+$ns at 20.0 "$qCE2 printStats"
+$ns at 40.0 "$qCE2 printStats"
+$ns at 60.0 "$qCE2 printStats"
+$ns at 80.0 "$qCE2 printStats"
+$ns at $testTime "$cbr0 stop"
+$ns at $testTime "$cbr1 stop"
+$ns at [expr $testTime + 1.0] "finish"
+
+$ns run
--- tcl/ex/diffserv/null.tcl	2003-11-27 18:29:20.000000000 -0500
+++ tcl/ex/diffserv/null.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,94 +1,94 @@
-# null.tcl
-# Author: Alexander Sayenko <sayenko@cc.jyu.fi>
-# Dates: Mon, 24 Nov 2003
-# Notes: A script to show the use of Null plicy
-
-set ns [new Simulator]
-
-set cir  1000000
-set cir2 500000
-
-set client  [$ns node]
-set client2 [$ns node]
-set border [$ns node]
-set core [$ns node]
-set server [$ns node]
-
-$ns simplex-link $client2 $border 10Mb 2ms DropTail
-$ns simplex-link $client $border 10Mb 2ms DropTail
-$ns simplex-link $border $core 10Mb 2ms dsRED/edge
-$ns simplex-link $core $server 10Mb 2ms dsRED/core
-
-set agent  [new Agent/UDP]
-set agent2 [new Agent/UDP]
-
-set sink   [new Agent/Null]
-set sink2  [new Agent/Null]
-
-set appl [new Application/Traffic/CBR]
-$appl set rate_ [expr $cir+10000]
-
-set appl2 [new Application/Traffic/CBR]
-$appl2 set rate_ $cir2
-
-$client attach $agent
-$client2 attach $agent2
-
-$server attach $sink
-$server attach $sink2
-
-$ns connect $agent $sink
-$ns connect $agent2 $sink2
-
-$appl attach-agent $agent
-$appl2 attach-agent $agent2
-
-set qBC [[$ns link $border $core] queue]
-set qCS [[$ns link $core $server] queue]
-
-# -------------------------------------------------
-$qBC set NumQueues_ 1
-$qBC setNumPrec 2
-
-$qBC addPolicyEntry [$client id] [$server id] TokenBucket 10 $cir 500
-$qBC addPolicerEntry TokenBucket 10 11
-
-$qBC addPolicyEntry [$client2 id] [$server id] Null 20
-$qBC addPolicerEntry Null 20
-
-$qBC addPHBEntry 10 0 0
-$qBC addPHBEntry 11 0 1
-$qBC addPHBEntry 20 0 0
-
-$qBC configQ 0 0 4 10 0.1
-$qBC configQ 0 1 2 5 0.5
-# -------------------------------------------------
-
-$qCS set NumQueues_ 1
-$qCS setNumPrec 2
-
-$qCS addPHBEntry 10 0 0
-$qCS addPHBEntry 11 0 1
-$qCS addPHBEntry 20 0 0
-
-$qCS configQ 0 0 4 10 0.1
-$qCS configQ 0 1 2 5 0.5
-# -------------------------------------------------
-
-$ns at 0 "$appl start; $appl2 start"
-$ns at 5 "finish"
-
-proc finish {} {
-
-  global ns
-  global qBC qCS
-
-  $qBC printStats
-  $qBC printPolicyTable
-  $qBC printPolicerTable
-
-  $ns halt
-
-}
-
-$ns run
+# null.tcl
+# Author: Alexander Sayenko <sayenko@cc.jyu.fi>
+# Dates: Mon, 24 Nov 2003
+# Notes: A script to show the use of Null plicy
+
+set ns [new Simulator]
+
+set cir  1000000
+set cir2 500000
+
+set client  [$ns node]
+set client2 [$ns node]
+set border [$ns node]
+set core [$ns node]
+set server [$ns node]
+
+$ns simplex-link $client2 $border 10Mb 2ms DropTail
+$ns simplex-link $client $border 10Mb 2ms DropTail
+$ns simplex-link $border $core 10Mb 2ms dsRED/edge
+$ns simplex-link $core $server 10Mb 2ms dsRED/core
+
+set agent  [new Agent/UDP]
+set agent2 [new Agent/UDP]
+
+set sink   [new Agent/Null]
+set sink2  [new Agent/Null]
+
+set appl [new Application/Traffic/CBR]
+$appl set rate_ [expr $cir+10000]
+
+set appl2 [new Application/Traffic/CBR]
+$appl2 set rate_ $cir2
+
+$client attach $agent
+$client2 attach $agent2
+
+$server attach $sink
+$server attach $sink2
+
+$ns connect $agent $sink
+$ns connect $agent2 $sink2
+
+$appl attach-agent $agent
+$appl2 attach-agent $agent2
+
+set qBC [[$ns link $border $core] queue]
+set qCS [[$ns link $core $server] queue]
+
+# -------------------------------------------------
+$qBC set NumQueues_ 1
+$qBC setNumPrec 2
+
+$qBC addPolicyEntry [$client id] [$server id] TokenBucket 10 $cir 500
+$qBC addPolicerEntry TokenBucket 10 11
+
+$qBC addPolicyEntry [$client2 id] [$server id] Null 20
+$qBC addPolicerEntry Null 20
+
+$qBC addPHBEntry 10 0 0
+$qBC addPHBEntry 11 0 1
+$qBC addPHBEntry 20 0 0
+
+$qBC configQ 0 0 4 10 0.1
+$qBC configQ 0 1 2 5 0.5
+# -------------------------------------------------
+
+$qCS set NumQueues_ 1
+$qCS setNumPrec 2
+
+$qCS addPHBEntry 10 0 0
+$qCS addPHBEntry 11 0 1
+$qCS addPHBEntry 20 0 0
+
+$qCS configQ 0 0 4 10 0.1
+$qCS configQ 0 1 2 5 0.5
+# -------------------------------------------------
+
+$ns at 0 "$appl start; $appl2 start"
+$ns at 5 "finish"
+
+proc finish {} {
+
+  global ns
+  global qBC qCS
+
+  $qBC printStats
+  $qBC printPolicyTable
+  $qBC printPolicerTable
+
+  $ns halt
+
+}
+
+$ns run
--- tcl/ex/redlight.tcl	2001-07-19 13:57:02.000000000 -0400
+++ tcl/ex/redlight.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,261 +1,261 @@
-#set stopTime 120
-set stopTime 10
-set ns [new Simulator]
-
-if {[llength $argv] > 0} {
-	set num_ftps [lindex $argv 0]
-} else {
-	set num_ftps 1
-}
-#set num_ftps [lindex $argv 0]
-
-
-if {[llength $argv] > 1} {
-	set num_webs [lindex $argv 1]
-} else {
-	set num_webs 0
-}
-if {[llength $argv] > 2} {
-	set bottleneck [lindex $argv 2]
-} else {
-	set bottleneck 1.5Mb
-}
-
-
-#set random_seed  [lindex $argv 3]
-set random_seed 0
-set rtt 100ms
-
-# ------- config info is all above this line ----------
-
-set rtt [$ns delay_parse $rtt]
-set bw [$ns bw_parse $bottleneck]
-if {$bw <= 128000} {
-	set psize 552
-} else {
-	set psize 1500
-}
-set bdp [expr round($bw*$rtt/(8*$psize))]
-if {$bdp < 5} {
-	set bdp 5
-}
-
-# allow lots of nodes (more than 128)
-#$ns set-address-format expanded
-
-Trace set show_tcphdr_ 1
-set startTime 0.0
-
-#TCP parameters
-
-Agent/TCP set window_ [expr $bdp*4]
-set win_size 1
-Agent/TCP set windowInit_ $win_size
-set segsize [expr $psize-40]
-set segperack 2
-set delack 0.4
-
-set lastsample 0
-set client_addr 0
-set no_of_inlines 3
-#set filesize [expr $stopTime*$bw/8/2]
-set filesize 10000000000
-
-
-#buffersizes
-set buffersize [expr $bdp*2]
-set buffersize1 [expr $bdp*2]
-
-#thresholds
-
-set minthresh [expr round(0.3*$bdp)]
-set maxthresh [expr round($minthresh + 1.0*$bdp)]
-
-set sampling_interval [expr $psize*8/$bw]
-# set sampling_interval 0.007
-
-set si_per_rtt [expr $rtt/$sampling_interval]
-for {set ptwo 2} {$ptwo < $si_per_rtt} {set ptwo [expr $ptwo*2]} { }
-set QWT [expr 1./$ptwo]
-
-
-puts "minthresh $minthresh  maxthresh $maxthresh  QWT $QWT  sample $sampling_interval"
-
-#set Flow_id 1
-ns-random $random_seed;
-puts $random_seed;
-#ns-random 0
-
-proc build_topology { ns which } {
-	global bw rtt bdp buffersize buffersize1 maxthresh minthresh QWT \
-	       sampling_interval
-
-	# congested link
-	global n0 n1
-	set n0 [$ns node]
-	set n1 [$ns node]
-	set bdelay [expr $rtt/2. - [$ns delay_parse 25ms]]
-        # $ns duplex-link $n0 $n1 $bw $bdelay RED/New
-        $ns duplex-link $n0 $n1 $bw $bdelay RED
-	$ns duplex-link-op $n0 $n1 orient right
-	$ns duplex-link-op $n1 $n0 queuePos 0.5
-	$ns queue-limit $n0 $n1 $buffersize
-	$ns queue-limit $n1 $n0 $buffersize
-
-	set li_10 [[$ns link $n1 $n0] queue]
-	$li_10 set maxthresh_ $maxthresh
-	$li_10 set thresh_ $minthresh
-	$li_10 set q_weight_ $QWT
-
-#	$li_10 sampling_interval $sampling_interval
-#	$li_10 cancel_thresh 0
-#	$li_10 drop_interval $buffersize
-
-	# $li_10 set queue-in-bytes_ true
-	# $li_10 set bytes_ true
-	# $li_10 set mean_pktsize_ 1500
-
-	set li_01 [[$ns link $n0 $n1] queue]
-	$li_01 set maxthresh_ $maxthresh
-	$li_01 set thresh_ $minthresh
-	$li_01 set q_weight_ $QWT
-	# $li_01 set queue-in-bytes_ true
-	# $li_01 set bytes_ true
-	# $li_01 set mean_pktsize_ 1500
-
-	global num_ftps num_webs
-	set n [expr $num_ftps+$num_webs]
-	for {set k 1} {$k <= $n} {incr k 1} {
-	    # clients
-	    set j [expr ($k+1)]
-	    set dly [expr ($k)]
-	    set dly 1
-	    global n$j
-	    set n$j [$ns node]
-	    set linkbw [expr $bw*10]
-	    $ns duplex-link [set n$j] $n0 $linkbw ${dly}ms DropTail
-	    $ns queue-limit [set n$j] $n0 $buffersize1
-	    $ns queue-limit $n0 [set n$j] $buffersize1
-	    set angle [expr $n>1? 0.75+($k-1)*.5/($n-1) : 1]
-	    $ns duplex-link-op $n0 [set n$j] orient $angle
-	    # servers
-	    set j [expr $k+$n+1]
-	    global n$j
-	    set n$j [$ns node]
-	    $ns duplex-link $n1 [set n$j] $linkbw  25ms  DropTail
-	    $ns queue-limit $n1 [set n$j] $buffersize1
-	    $ns queue-limit [set n$j] $n1 $buffersize1
-	    set angle [expr $n>1? fmod(2.25-($k-1)*.5/($n-1), 2) : 0]
-	    $ns duplex-link-op $n1 [set n$j] orient $angle
-	}
-}
-
-
-proc build_ftpclient {cnd snd sftp startTime timeToStop Flow_id} {
-    
-    global ns
-    global stopTime
-    set cli [get_ftpclient]
-    set ctcp [get_fulltcp]
-    $ctcp attach-application $cli
-    #set cli [$ctcp attach-app FTP]
-    $ctcp set fid_ $Flow_id
-    $cli tcp $ctcp
-    $ns attach-agent $cnd $ctcp
-
-    set stcp [get_fulltcp]
-    $stcp attach-application $sftp
-    $stcp set fid_ $Flow_id
-    $ns attach-agent $snd $stcp
-
-    $ns connect $ctcp $stcp
-    #$ctcp set dst_ [$stcp set addr_]
-    $stcp listen
-    $ns at $startTime "$cli start"
-    $ns at $timeToStop "$cli stop"
-    global ftplist
-    global ftplist
-    set ftplist($ctcp) $stcp
-    return $cli
-}
-
-
-
-
-proc get_ftpclient {} {
-    global client_addr
-    set cli [new Agent/BayTcpApp/FtpClient]
-    #set cli [new Agent/TcpApp/FtpClient]
-    $cli set addr_ [incr client_addr]
-    return $cli
-}
-
-
-proc get_fulltcp {} {
-    global segperack segsize delack
-    set atcp [new Agent/TCP/BayFullTcp]
-    #set atcp [new Agent/TCP/FullTcp]
-    $atcp set segsperack_ $segperack
-    $atcp set segsize_ $segsize
-    $atcp set interval_ $delack
-    return $atcp
-}
-    
-
-proc uniform {a b} {
-	expr $a + (($b- $a) * ([ns-random]*1.0/0x7fffffff))
-}
-
-proc finish {} {
-        global ns PERL
-	$ns halt
-        $ns flush-trace
-    set wrap [expr 90 * 1000 + 40]
-    set file BayFullTCP
-    exec $PERL ../../bin/set_flow_id -s bay-out.tr | \
-	    $PERL ../../bin/getrc -e -s 1 -d 0 | \
-	    $PERL ../../bin/raw2xg -v -s 0.01 -m $wrap -t $file > temp.rands
-    exec xgraph -bb -tk -nl -m -x time -y packets temp.rands &
-        exit 0
-}
-$ns trace-all [open bay-out.tr w]
-$ns namtrace-all [open bay-out.nam w]
-$ns color 2 blue
-$ns color 3 red
-$ns color 4 yellow
-$ns color 5 green
-
-#build_topology $ns RED/New
-build_topology $ns RED
-
-set fname f${num_ftps}w${num_webs}b${bottleneck}.tr
-#set fname /dev/fd/1
-$ns trace-queue $n1 $n0 [open $fname w]
-
-set nn [expr $num_ftps+$num_webs]
-for {set k 1} {$k <= $num_ftps} {incr k 1} {
-    set j [expr $k+1]
-    set i [expr $j+$nn]
-    set sftp [new Agent/BayTcpApp/FtpServer]
-    #set sftp [new Agent/TcpApp/FtpServer]
-    $sftp file_size $filesize
-    build_ftpclient [set n$j] [set n$i]  $sftp \
-    		[expr ($k-1)*[uniform 0.0 2.0]] 225 $j
-}
-
-
-$ns at [expr $stopTime ] "finish"
-$ns run
-exit 0
-
-
-
-
-
-
-
-
-
-
-
-
+#set stopTime 120
+set stopTime 10
+set ns [new Simulator]
+
+if {[llength $argv] > 0} {
+	set num_ftps [lindex $argv 0]
+} else {
+	set num_ftps 1
+}
+#set num_ftps [lindex $argv 0]
+
+
+if {[llength $argv] > 1} {
+	set num_webs [lindex $argv 1]
+} else {
+	set num_webs 0
+}
+if {[llength $argv] > 2} {
+	set bottleneck [lindex $argv 2]
+} else {
+	set bottleneck 1.5Mb
+}
+
+
+#set random_seed  [lindex $argv 3]
+set random_seed 0
+set rtt 100ms
+
+# ------- config info is all above this line ----------
+
+set rtt [$ns delay_parse $rtt]
+set bw [$ns bw_parse $bottleneck]
+if {$bw <= 128000} {
+	set psize 552
+} else {
+	set psize 1500
+}
+set bdp [expr round($bw*$rtt/(8*$psize))]
+if {$bdp < 5} {
+	set bdp 5
+}
+
+# allow lots of nodes (more than 128)
+#$ns set-address-format expanded
+
+Trace set show_tcphdr_ 1
+set startTime 0.0
+
+#TCP parameters
+
+Agent/TCP set window_ [expr $bdp*4]
+set win_size 1
+Agent/TCP set windowInit_ $win_size
+set segsize [expr $psize-40]
+set segperack 2
+set delack 0.4
+
+set lastsample 0
+set client_addr 0
+set no_of_inlines 3
+#set filesize [expr $stopTime*$bw/8/2]
+set filesize 10000000000
+
+
+#buffersizes
+set buffersize [expr $bdp*2]
+set buffersize1 [expr $bdp*2]
+
+#thresholds
+
+set minthresh [expr round(0.3*$bdp)]
+set maxthresh [expr round($minthresh + 1.0*$bdp)]
+
+set sampling_interval [expr $psize*8/$bw]
+# set sampling_interval 0.007
+
+set si_per_rtt [expr $rtt/$sampling_interval]
+for {set ptwo 2} {$ptwo < $si_per_rtt} {set ptwo [expr $ptwo*2]} { }
+set QWT [expr 1./$ptwo]
+
+
+puts "minthresh $minthresh  maxthresh $maxthresh  QWT $QWT  sample $sampling_interval"
+
+#set Flow_id 1
+ns-random $random_seed;
+puts $random_seed;
+#ns-random 0
+
+proc build_topology { ns which } {
+	global bw rtt bdp buffersize buffersize1 maxthresh minthresh QWT \
+	       sampling_interval
+
+	# congested link
+	global n0 n1
+	set n0 [$ns node]
+	set n1 [$ns node]
+	set bdelay [expr $rtt/2. - [$ns delay_parse 25ms]]
+        # $ns duplex-link $n0 $n1 $bw $bdelay RED/New
+        $ns duplex-link $n0 $n1 $bw $bdelay RED
+	$ns duplex-link-op $n0 $n1 orient right
+	$ns duplex-link-op $n1 $n0 queuePos 0.5
+	$ns queue-limit $n0 $n1 $buffersize
+	$ns queue-limit $n1 $n0 $buffersize
+
+	set li_10 [[$ns link $n1 $n0] queue]
+	$li_10 set maxthresh_ $maxthresh
+	$li_10 set thresh_ $minthresh
+	$li_10 set q_weight_ $QWT
+
+#	$li_10 sampling_interval $sampling_interval
+#	$li_10 cancel_thresh 0
+#	$li_10 drop_interval $buffersize
+
+	# $li_10 set queue-in-bytes_ true
+	# $li_10 set bytes_ true
+	# $li_10 set mean_pktsize_ 1500
+
+	set li_01 [[$ns link $n0 $n1] queue]
+	$li_01 set maxthresh_ $maxthresh
+	$li_01 set thresh_ $minthresh
+	$li_01 set q_weight_ $QWT
+	# $li_01 set queue-in-bytes_ true
+	# $li_01 set bytes_ true
+	# $li_01 set mean_pktsize_ 1500
+
+	global num_ftps num_webs
+	set n [expr $num_ftps+$num_webs]
+	for {set k 1} {$k <= $n} {incr k 1} {
+	    # clients
+	    set j [expr ($k+1)]
+	    set dly [expr ($k)]
+	    set dly 1
+	    global n$j
+	    set n$j [$ns node]
+	    set linkbw [expr $bw*10]
+	    $ns duplex-link [set n$j] $n0 $linkbw ${dly}ms DropTail
+	    $ns queue-limit [set n$j] $n0 $buffersize1
+	    $ns queue-limit $n0 [set n$j] $buffersize1
+	    set angle [expr $n>1? 0.75+($k-1)*.5/($n-1) : 1]
+	    $ns duplex-link-op $n0 [set n$j] orient $angle
+	    # servers
+	    set j [expr $k+$n+1]
+	    global n$j
+	    set n$j [$ns node]
+	    $ns duplex-link $n1 [set n$j] $linkbw  25ms  DropTail
+	    $ns queue-limit $n1 [set n$j] $buffersize1
+	    $ns queue-limit [set n$j] $n1 $buffersize1
+	    set angle [expr $n>1? fmod(2.25-($k-1)*.5/($n-1), 2) : 0]
+	    $ns duplex-link-op $n1 [set n$j] orient $angle
+	}
+}
+
+
+proc build_ftpclient {cnd snd sftp startTime timeToStop Flow_id} {
+    
+    global ns
+    global stopTime
+    set cli [get_ftpclient]
+    set ctcp [get_fulltcp]
+    $ctcp attach-application $cli
+    #set cli [$ctcp attach-app FTP]
+    $ctcp set fid_ $Flow_id
+    $cli tcp $ctcp
+    $ns attach-agent $cnd $ctcp
+
+    set stcp [get_fulltcp]
+    $stcp attach-application $sftp
+    $stcp set fid_ $Flow_id
+    $ns attach-agent $snd $stcp
+
+    $ns connect $ctcp $stcp
+    #$ctcp set dst_ [$stcp set addr_]
+    $stcp listen
+    $ns at $startTime "$cli start"
+    $ns at $timeToStop "$cli stop"
+    global ftplist
+    global ftplist
+    set ftplist($ctcp) $stcp
+    return $cli
+}
+
+
+
+
+proc get_ftpclient {} {
+    global client_addr
+    set cli [new Agent/BayTcpApp/FtpClient]
+    #set cli [new Agent/TcpApp/FtpClient]
+    $cli set addr_ [incr client_addr]
+    return $cli
+}
+
+
+proc get_fulltcp {} {
+    global segperack segsize delack
+    set atcp [new Agent/TCP/BayFullTcp]
+    #set atcp [new Agent/TCP/FullTcp]
+    $atcp set segsperack_ $segperack
+    $atcp set segsize_ $segsize
+    $atcp set interval_ $delack
+    return $atcp
+}
+    
+
+proc uniform {a b} {
+	expr $a + (($b- $a) * ([ns-random]*1.0/0x7fffffff))
+}
+
+proc finish {} {
+        global ns PERL
+	$ns halt
+        $ns flush-trace
+    set wrap [expr 90 * 1000 + 40]
+    set file BayFullTCP
+    exec $PERL ../../bin/set_flow_id -s bay-out.tr | \
+	    $PERL ../../bin/getrc -e -s 1 -d 0 | \
+	    $PERL ../../bin/raw2xg -v -s 0.01 -m $wrap -t $file > temp.rands
+    exec xgraph -bb -tk -nl -m -x time -y packets temp.rands &
+        exit 0
+}
+$ns trace-all [open bay-out.tr w]
+$ns namtrace-all [open bay-out.nam w]
+$ns color 2 blue
+$ns color 3 red
+$ns color 4 yellow
+$ns color 5 green
+
+#build_topology $ns RED/New
+build_topology $ns RED
+
+set fname f${num_ftps}w${num_webs}b${bottleneck}.tr
+#set fname /dev/fd/1
+$ns trace-queue $n1 $n0 [open $fname w]
+
+set nn [expr $num_ftps+$num_webs]
+for {set k 1} {$k <= $num_ftps} {incr k 1} {
+    set j [expr $k+1]
+    set i [expr $j+$nn]
+    set sftp [new Agent/BayTcpApp/FtpServer]
+    #set sftp [new Agent/TcpApp/FtpServer]
+    $sftp file_size $filesize
+    build_ftpclient [set n$j] [set n$i]  $sftp \
+    		[expr ($k-1)*[uniform 0.0 2.0]] 225 $j
+}
+
+
+$ns at [expr $stopTime ] "finish"
+$ns run
+exit 0
+
+
+
+
+
+
+
+
+
+
+
+
--- tcl/ex/simple-wireless.tcl	1999-11-08 16:13:18.000000000 -0500
+++ tcl/ex/simple-wireless.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,148 +1,148 @@
-# Copyright (c) 1997 Regents of the University of California.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. All advertising materials mentioning features or use of this software
-#    must display the following acknowledgement:
-#      This product includes software developed by the Computer Systems
-#      Engineering Group at Lawrence Berkeley Laboratory.
-# 4. Neither the name of the University nor of the Laboratory may be used
-#    to endorse or promote products derived from this software without
-#    specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-# simple-wireless.tcl
-# A simple example for wireless simulation
-
-# ======================================================================
-# Define options
-# ======================================================================
-set val(chan)           Channel/WirelessChannel    ;# channel type
-set val(prop)           Propagation/TwoRayGround   ;# radio-propagation model
-set val(netif)          Phy/WirelessPhy            ;# network interface type
-set val(mac)            Mac/802_11                 ;# MAC type
-set val(ifq)            Queue/DropTail/PriQueue    ;# interface queue type
-set val(ll)             LL                         ;# link layer type
-set val(ant)            Antenna/OmniAntenna        ;# antenna model
-set val(ifqlen)         50                         ;# max packet in ifq
-set val(nn)             2                          ;# number of mobilenodes
-set val(rp)             DSDV                       ;# routing protocol
-
-# ======================================================================
-# Main Program
-# ======================================================================
-
-
-#
-# Initialize Global Variables
-#
-set ns_		[new Simulator]
-set tracefd     [open simple.tr w]
-$ns_ trace-all $tracefd
-
-# set up topography object
-set topo       [new Topography]
-
-$topo load_flatgrid 500 500
-
-#
-# Create God
-#
-create-god $val(nn)
-
-#
-#  Create the specified number of mobilenodes [$val(nn)] and "attach" them
-#  to the channel. 
-#  Here two nodes are created : node(0) and node(1)
-
-# configure node
-
-        $ns_ node-config -adhocRouting $val(rp) \
-			 -llType $val(ll) \
-			 -macType $val(mac) \
-			 -ifqType $val(ifq) \
-			 -ifqLen $val(ifqlen) \
-			 -antType $val(ant) \
-			 -propType $val(prop) \
-			 -phyType $val(netif) \
-			 -channelType $val(chan) \
-			 -topoInstance $topo \
-			 -agentTrace ON \
-			 -routerTrace ON \
-			 -macTrace OFF \
-			 -movementTrace OFF			
-			 
-	for {set i 0} {$i < $val(nn) } {incr i} {
-		set node_($i) [$ns_ node]	
-		$node_($i) random-motion 0		;# disable random motion
-	}
-
-#
-# Provide initial (X,Y, for now Z=0) co-ordinates for mobilenodes
-#
-$node_(0) set X_ 5.0
-$node_(0) set Y_ 2.0
-$node_(0) set Z_ 0.0
-
-$node_(1) set X_ 390.0
-$node_(1) set Y_ 385.0
-$node_(1) set Z_ 0.0
-
-#
-# Now produce some simple node movements
-# Node_(1) starts to move towards node_(0)
-#
-$ns_ at 50.0 "$node_(1) setdest 25.0 20.0 15.0"
-$ns_ at 10.0 "$node_(0) setdest 20.0 18.0 1.0"
-
-# Node_(1) then starts to move away from node_(0)
-$ns_ at 100.0 "$node_(1) setdest 490.0 480.0 15.0" 
-
-# Setup traffic flow between nodes
-# TCP connections between node_(0) and node_(1)
-
-set tcp [new Agent/TCP]
-$tcp set class_ 2
-set sink [new Agent/TCPSink]
-$ns_ attach-agent $node_(0) $tcp
-$ns_ attach-agent $node_(1) $sink
-$ns_ connect $tcp $sink
-set ftp [new Application/FTP]
-$ftp attach-agent $tcp
-$ns_ at 10.0 "$ftp start" 
-
-#
-# Tell nodes when the simulation ends
-#
-for {set i 0} {$i < $val(nn) } {incr i} {
-    $ns_ at 150.0 "$node_($i) reset";
-}
-$ns_ at 150.0 "stop"
-$ns_ at 150.01 "puts \"NS EXITING...\" ; $ns_ halt"
-proc stop {} {
-    global ns_ tracefd
-    $ns_ flush-trace
-    close $tracefd
-}
-
-puts "Starting Simulation..."
-$ns_ run
-
+# Copyright (c) 1997 Regents of the University of California.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. All advertising materials mentioning features or use of this software
+#    must display the following acknowledgement:
+#      This product includes software developed by the Computer Systems
+#      Engineering Group at Lawrence Berkeley Laboratory.
+# 4. Neither the name of the University nor of the Laboratory may be used
+#    to endorse or promote products derived from this software without
+#    specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+# simple-wireless.tcl
+# A simple example for wireless simulation
+
+# ======================================================================
+# Define options
+# ======================================================================
+set val(chan)           Channel/WirelessChannel    ;# channel type
+set val(prop)           Propagation/TwoRayGround   ;# radio-propagation model
+set val(netif)          Phy/WirelessPhy            ;# network interface type
+set val(mac)            Mac/802_11                 ;# MAC type
+set val(ifq)            Queue/DropTail/PriQueue    ;# interface queue type
+set val(ll)             LL                         ;# link layer type
+set val(ant)            Antenna/OmniAntenna        ;# antenna model
+set val(ifqlen)         50                         ;# max packet in ifq
+set val(nn)             2                          ;# number of mobilenodes
+set val(rp)             DSDV                       ;# routing protocol
+
+# ======================================================================
+# Main Program
+# ======================================================================
+
+
+#
+# Initialize Global Variables
+#
+set ns_		[new Simulator]
+set tracefd     [open simple.tr w]
+$ns_ trace-all $tracefd
+
+# set up topography object
+set topo       [new Topography]
+
+$topo load_flatgrid 500 500
+
+#
+# Create God
+#
+create-god $val(nn)
+
+#
+#  Create the specified number of mobilenodes [$val(nn)] and "attach" them
+#  to the channel. 
+#  Here two nodes are created : node(0) and node(1)
+
+# configure node
+
+        $ns_ node-config -adhocRouting $val(rp) \
+			 -llType $val(ll) \
+			 -macType $val(mac) \
+			 -ifqType $val(ifq) \
+			 -ifqLen $val(ifqlen) \
+			 -antType $val(ant) \
+			 -propType $val(prop) \
+			 -phyType $val(netif) \
+			 -channelType $val(chan) \
+			 -topoInstance $topo \
+			 -agentTrace ON \
+			 -routerTrace ON \
+			 -macTrace OFF \
+			 -movementTrace OFF			
+			 
+	for {set i 0} {$i < $val(nn) } {incr i} {
+		set node_($i) [$ns_ node]	
+		$node_($i) random-motion 0		;# disable random motion
+	}
+
+#
+# Provide initial (X,Y, for now Z=0) co-ordinates for mobilenodes
+#
+$node_(0) set X_ 5.0
+$node_(0) set Y_ 2.0
+$node_(0) set Z_ 0.0
+
+$node_(1) set X_ 390.0
+$node_(1) set Y_ 385.0
+$node_(1) set Z_ 0.0
+
+#
+# Now produce some simple node movements
+# Node_(1) starts to move towards node_(0)
+#
+$ns_ at 50.0 "$node_(1) setdest 25.0 20.0 15.0"
+$ns_ at 10.0 "$node_(0) setdest 20.0 18.0 1.0"
+
+# Node_(1) then starts to move away from node_(0)
+$ns_ at 100.0 "$node_(1) setdest 490.0 480.0 15.0" 
+
+# Setup traffic flow between nodes
+# TCP connections between node_(0) and node_(1)
+
+set tcp [new Agent/TCP]
+$tcp set class_ 2
+set sink [new Agent/TCPSink]
+$ns_ attach-agent $node_(0) $tcp
+$ns_ attach-agent $node_(1) $sink
+$ns_ connect $tcp $sink
+set ftp [new Application/FTP]
+$ftp attach-agent $tcp
+$ns_ at 10.0 "$ftp start" 
+
+#
+# Tell nodes when the simulation ends
+#
+for {set i 0} {$i < $val(nn) } {incr i} {
+    $ns_ at 150.0 "$node_($i) reset";
+}
+$ns_ at 150.0 "stop"
+$ns_ at 150.01 "puts \"NS EXITING...\" ; $ns_ halt"
+proc stop {} {
+    global ns_ tracefd
+    $ns_ flush-trace
+    close $tracefd
+}
+
+puts "Starting Simulation..."
+$ns_ run
+
--- tcl/ex/topo-gen.tcl	1998-10-21 19:29:40.000000000 -0400
+++ tcl/ex/topo-gen.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,5 +1,5 @@
-# Created May 98 by Ahmed Helmy; updated June 98
-# topology generator class
+# Created May 98 by Ahmed Helmy; updated June 98
+# topology generator class
 Class TG
 
 proc usage { } {
@@ -33,7 +33,7 @@
   possible values: random (default), transit_stub
 
 -seed
-  possible values: integer (default = random [uses ns-random])
+  possible values: integer (default = random [uses ns-random])
 
 -nodes [the number of nodes in the topology; used with `-type random']
   possible values: integer (default = 50 with random, 100 with 
@@ -105,351 +105,351 @@
 -domains_connection_prob (default = 1.0) [fully connected]
 -domains_beta (default = 0.5)
 -domains_gamma (default = 0.5)
-
-* Connectivity of transit nodes:
--transit_nodes (default = 4)
--transit_scale (default = 20)
--transit_method (default = pure-random)
--transit_connection_prob (default = 0.6)
--transit_beta (default = 0.5)
--transit_gamma (default = 0.5)
-
-* Connectivity of stub nodes:
--stub_nodes (default = 8)
--stub_method (default = pure-random)
--stub_connection_prob (default = 0.4)
--stub_beta (default = 0.5)
--stub_gamma (default = 0.5)
-
-* Total number of nodes is computed as follows:      
- nodes=transit_domains * transit_nodes * (1 + stubs_per_transit * stub_nodes)
-
- for example, for the above default settings we get:
-        1 * 4 ( 1 + 3 * 8 ) = 100 nodes
-  }
-
-}
-
-proc help-on-help { } {
-	puts {Help available for random, transit stub, and edge connection method.
-
-Help usage "topology -h <i>" 
-where: 
-<i> = 1 for random, 2 for transit stub, and 3 for edge connection method.
-  }
-}
-
-proc help { x } {
-	switch $x {
-		1 { detailed-usage }
-		2 { itm-transit-stub-help }
-		3 { itm-random-help }
-		default { puts "invalid help option"; help-on-help } 
-	}
-}
-
-proc topology { args } {
-	set len [llength $args]
-
-	if $len {
-	    set key [lindex $args 0]
-            if {$key == "-?" || $key == "--help" || $key == "-help" \
-			|| $key == "-h" } {
-				if { [set arg2 [lindex $args 1]] == "" } {
-					usage
-					help-on-help
-				} else {
-                        	help $arg2
-				}
-			return
-                }
-	}
-
-        if [expr $len % 2] {
-                # if number is odd => error !
-                puts "fewer number of arguments than needed in \"$args\""
-                usage
-		return
-        }
-
-        # default topology generator
-        set generator itm
-
-        if { $args != "" && [lindex $args 0] == "-generator" } {
-		set generator [lindex $args 1]
-		set args [lreplace $args 0 1]
-	}
-
-	# check if the generator type exists
-	if [catch {set tg [TG/$generator info instances]}] {
-		puts "unknown generator type $generator"
-		usage
-		return
-	}
-	if { $tg == "" } {
-		set tg [new TG/$generator]
-	}
-	if ![llength $args] {
-		$tg create
-	} else {
-		$tg create $args
-	}
-	ScenGen setTG $tg
-}
-
-Class TG/itm -superclass TG
-
-TG/itm instproc init { } {
-	$self next
-}
-
-TG/itm instproc default_options { } {
-	# default set may not be complete for now.. !XXX
-	$self instvar opt_info
-
-	set opt_info {
-		# init file to -1, must be supplied by input
-		outfile -1
-
-		# number of graphs and seed
-		# flat random
-		type random
-
-		# number should not be changed by input... should be left 
-		# as 1, and a tcl loop may create multiple graphs... left it as 
-		# place holder in case this may change later.. !
-		number 1
-		# seed is randomized later if not entered as input
-		seed -1
-
-		nodes 50
-		# if not entered assign to nodes later 
-		scale -1 
-		
-		method pure-random
-		connection_prob 0.5
-
-		beta 0.5
-		gamma 0.5
-
-		# defaults for transit stub
-	# total number of nodes is:
-	# transit_domains * transit_nodes * (1 + stubs_per_transit * stub_nodes)
-	# 1 * 4 ( 1 + 3 * 8 ) = 100 nodes
-		stubs_per_transit 3
-		ts_extra_edges 0
-		ss_extra_edges 0
-
-		transit_domains 1
-		domains_scale 20
-		domains_method pure-random
-		domains_connection_prob 1.0
-		domains_beta 0.5
-		domains_gamma 0.5
-
-		transit_nodes 4
-		transit_scale 20
-		transit_method pure-random
-		transit_connection_prob 0.6
-		transit_beta 0.5
-		transit_gamma 0.5
-
-		stub_nodes 8
-		# the stub scale is ignored by ITM, is computed as fraction
-		# of the transit scale... see proc comment below !
-		stub_scale 10
-		stub_method pure-random
-		stub_connection_prob 0.4
-		stub_beta 0.5
-		stub_gamma 0.5
-
-		# for N level hierarchy
-		# assume all levels use same vars
-		levels 3
-		level_nodes 10
-		level_scale 10
-		level_method waxman1
-		level_connection_prob 0.7
-		level_beta 0.2
-		level_gamma 0.5
-	}
-	$self parse_opts
-}
-	
-TG instproc parse_opts { } {
-	$self instvar opts opt_info
-
-	while { $opt_info != ""} {
-		# parse line by line
-                if {![regexp "^\[^\n\]*\n" $opt_info line]} {
-                        break  
-                }
-		# remove the parsed line
-                regsub "^\[^\n\]*\n" $opt_info {} opt_info
-		# remove leading spaces and tabs using trim
-                set line [string trim $line]
-		# skip comment lines beginning with #
-                if {[regexp "^\[ \t\]*#" $line]} {
-                        continue
-                }
-		# skip empty lines
-                if {$line == ""} {
-                        continue
-                } elseif [regexp {^([^ ]+)[ ]+([^ ]+)$} $line dummy key value] {
-                        set opts($key) $value
-                } 
-	}
-}
-
-TG instproc parse_input { args } {
-	# remove the list brackets from the args list
-        set args [lindex $args 0]
-        set len [llength $args]
-
-	$self instvar opts
-
-	for { set i 0 } { $i < $len } { incr i } {
-		set key [lindex $args $i]
-		regsub {^-} $key {} key
-                if {![info exists opts($key)]} {
-			puts stderr "unrecognized option $key"
-			usage
-			return -1
-		}
-		incr i
-		# puts "changing $key from $opts($key) to [lindex $args $i]"
-		set opts($key) [lindex $args $i]
-	}
-	# puts "end of parsing... "
-	return 0
-}
-
-TG instproc create { args } {
-        # remove the list brackets from the args list
-        set args [lindex $args 0]
-        set len [llength $args]
-        # puts "calling create with args $args, len $len"
-
-	$self default_options
-
-	if $len {
-		if { [$self parse_input $args] == -1 } {
-			return 
-		}
-	}
-	# check that the filename is provided
-	$self instvar opts
-	if { $opts(outfile) == -1 } {
-puts {you must provide the outfile name !!.. use "topology -h" for help}
-		return
-	}
-	$self create-topology
-}
-
+
+* Connectivity of transit nodes:
+-transit_nodes (default = 4)
+-transit_scale (default = 20)
+-transit_method (default = pure-random)
+-transit_connection_prob (default = 0.6)
+-transit_beta (default = 0.5)
+-transit_gamma (default = 0.5)
+
+* Connectivity of stub nodes:
+-stub_nodes (default = 8)
+-stub_method (default = pure-random)
+-stub_connection_prob (default = 0.4)
+-stub_beta (default = 0.5)
+-stub_gamma (default = 0.5)
+
+* Total number of nodes is computed as follows:      
+ nodes=transit_domains * transit_nodes * (1 + stubs_per_transit * stub_nodes)
+
+ for example, for the above default settings we get:
+        1 * 4 ( 1 + 3 * 8 ) = 100 nodes
+  }
+
+}
+
+proc help-on-help { } {
+	puts {Help available for random, transit stub, and edge connection method.
+
+Help usage "topology -h <i>" 
+where: 
+<i> = 1 for random, 2 for transit stub, and 3 for edge connection method.
+  }
+}
+
+proc help { x } {
+	switch $x {
+		1 { detailed-usage }
+		2 { itm-transit-stub-help }
+		3 { itm-random-help }
+		default { puts "invalid help option"; help-on-help } 
+	}
+}
+
+proc topology { args } {
+	set len [llength $args]
+
+	if $len {
+	    set key [lindex $args 0]
+            if {$key == "-?" || $key == "--help" || $key == "-help" \
+			|| $key == "-h" } {
+				if { [set arg2 [lindex $args 1]] == "" } {
+					usage
+					help-on-help
+				} else {
+                        	help $arg2
+				}
+			return
+                }
+	}
+
+        if [expr $len % 2] {
+                # if number is odd => error !
+                puts "fewer number of arguments than needed in \"$args\""
+                usage
+		return
+        }
+
+        # default topology generator
+        set generator itm
+
+        if { $args != "" && [lindex $args 0] == "-generator" } {
+		set generator [lindex $args 1]
+		set args [lreplace $args 0 1]
+	}
+
+	# check if the generator type exists
+	if [catch {set tg [TG/$generator info instances]}] {
+		puts "unknown generator type $generator"
+		usage
+		return
+	}
+	if { $tg == "" } {
+		set tg [new TG/$generator]
+	}
+	if ![llength $args] {
+		$tg create
+	} else {
+		$tg create $args
+	}
+	ScenGen setTG $tg
+}
+
+Class TG/itm -superclass TG
+
+TG/itm instproc init { } {
+	$self next
+}
+
+TG/itm instproc default_options { } {
+	# default set may not be complete for now.. !XXX
+	$self instvar opt_info
+
+	set opt_info {
+		# init file to -1, must be supplied by input
+		outfile -1
+
+		# number of graphs and seed
+		# flat random
+		type random
+
+		# number should not be changed by input... should be left 
+		# as 1, and a tcl loop may create multiple graphs... left it as 
+		# place holder in case this may change later.. !
+		number 1
+		# seed is randomized later if not entered as input
+		seed -1
+
+		nodes 50
+		# if not entered assign to nodes later 
+		scale -1 
+		
+		method pure-random
+		connection_prob 0.5
+
+		beta 0.5
+		gamma 0.5
+
+		# defaults for transit stub
+	# total number of nodes is:
+	# transit_domains * transit_nodes * (1 + stubs_per_transit * stub_nodes)
+	# 1 * 4 ( 1 + 3 * 8 ) = 100 nodes
+		stubs_per_transit 3
+		ts_extra_edges 0
+		ss_extra_edges 0
+
+		transit_domains 1
+		domains_scale 20
+		domains_method pure-random
+		domains_connection_prob 1.0
+		domains_beta 0.5
+		domains_gamma 0.5
+
+		transit_nodes 4
+		transit_scale 20
+		transit_method pure-random
+		transit_connection_prob 0.6
+		transit_beta 0.5
+		transit_gamma 0.5
+
+		stub_nodes 8
+		# the stub scale is ignored by ITM, is computed as fraction
+		# of the transit scale... see proc comment below !
+		stub_scale 10
+		stub_method pure-random
+		stub_connection_prob 0.4
+		stub_beta 0.5
+		stub_gamma 0.5
+
+		# for N level hierarchy
+		# assume all levels use same vars
+		levels 3
+		level_nodes 10
+		level_scale 10
+		level_method waxman1
+		level_connection_prob 0.7
+		level_beta 0.2
+		level_gamma 0.5
+	}
+	$self parse_opts
+}
 	
+TG instproc parse_opts { } {
+	$self instvar opts opt_info
 
-# XXX to be extended to include stubs... and other topo info
-TG instproc setNodes { type num } {
-	$self instvar nodes
+	while { $opt_info != ""} {
+		# parse line by line
+                if {![regexp "^\[^\n\]*\n" $opt_info line]} {
+                        break  
+                }
+		# remove the parsed line
+                regsub "^\[^\n\]*\n" $opt_info {} opt_info
+		# remove leading spaces and tabs using trim
+                set line [string trim $line]
+		# skip comment lines beginning with #
+                if {[regexp "^\[ \t\]*#" $line]} {
+                        continue
+                }
+		# skip empty lines
+                if {$line == ""} {
+                        continue
+                } elseif [regexp {^([^ ]+)[ ]+([^ ]+)$} $line dummy key value] {
+                        set opts($key) $value
+                } 
+	}
+}
+
+TG instproc parse_input { args } {
+	# remove the list brackets from the args list
+        set args [lindex $args 0]
+        set len [llength $args]
+
+	$self instvar opts
+
+	for { set i 0 } { $i < $len } { incr i } {
+		set key [lindex $args $i]
+		regsub {^-} $key {} key
+                if {![info exists opts($key)]} {
+			puts stderr "unrecognized option $key"
+			usage
+			return -1
+		}
+		incr i
+		# puts "changing $key from $opts($key) to [lindex $args $i]"
+		set opts($key) [lindex $args $i]
+	}
+	# puts "end of parsing... "
+	return 0
+}
+
+TG instproc create { args } {
+        # remove the list brackets from the args list
+        set args [lindex $args 0]
+        set len [llength $args]
+        # puts "calling create with args $args, len $len"
+
+	$self default_options
+
+	if $len {
+		if { [$self parse_input $args] == -1 } {
+			return 
+		}
+	}
+	# check that the filename is provided
+	$self instvar opts
+	if { $opts(outfile) == -1 } {
+puts {you must provide the outfile name !!.. use "topology -h" for help}
+		return
+	}
+	$self create-topology
+}
+
+	
+
+# XXX to be extended to include stubs... and other topo info
+TG instproc setNodes { type num } {
+	$self instvar nodes
 	set nodes($type) $num
 	# puts "nodes($type) = $nodes($type)"
 
-	# now we stor nodes(all) x
-	# should be able to store nodes(stub1) x1-x2
-	# keep track of the num of stubs... etc
-}
-
-TG instproc getNodes { type } {
-	$self instvar nodes
+	# now we stor nodes(all) x
+	# should be able to store nodes(stub1) x1-x2
+	# keep track of the num of stubs... etc
+}
+
+TG instproc getNodes { type } {
+	$self instvar nodes
 	if { ![info exists nodes($type)]} {
 		puts "error: $type doesnot exist! Check srcstub/deststub arguments"
 		exit
 	}
-	return $nodes($type)
+	return $nodes($type)
 }
 
-TG/itm instproc create-topology { } {
+TG/itm instproc create-topology { } {
 
-	$self instvar opts
+	$self instvar opts
 
-	# initialize the seed if not given
+	# initialize the seed if not given
 	if { $opts(seed) == -1 } {
-		set opts(seed) [ns-random]
+		set opts(seed) [ns-random]
 	}
 
-	puts "type $opts(type), seed $opts(seed)"
+	puts "type $opts(type), seed $opts(seed)"
+
+	switch $opts(type) {
+	  "random" {
+		# compose the filename
+		set i 0
+		while { 1 } {
+			# avoid clashing with prev files, incr i
+			set topo_filename rand-$opts(nodes)-$i
+			if ![file exists $topo_filename] {
+				break
+			}
+			incr i
+		}
+		set topo_file [open $topo_filename w]
+
+                # write to a file in GA tech format  
+                # for now generate 1 graph,... 
+		# check the scale, if not give, assign # of nodes
+		if { $opts(scale) == -1 } {
+			set opts(scale) $opts(nodes)
+		}
+
+		$self setNodes all $opts(nodes)
 
-	switch $opts(type) {
-	  "random" {
-		# compose the filename
-		set i 0
-		while { 1 } {
-			# avoid clashing with prev files, incr i
-			set topo_filename rand-$opts(nodes)-$i
-			if ![file exists $topo_filename] {
-				break
-			}
-			incr i
-		}
-		set topo_file [open $topo_filename w]
-
-                # write to a file in GA tech format  
-                # for now generate 1 graph,... 
-		# check the scale, if not give, assign # of nodes
-		if { $opts(scale) == -1 } {
-			set opts(scale) $opts(nodes)
-		}
-
-		$self setNodes all $opts(nodes)
-
-		puts "nodes $opts(nodes), scale $opts(scale), \
-		     method $opts(method)"
-		puts "conn prob $opts(connection_prob), beta \
-		     $opts(beta), gamma $opts(gamma)"
-
-                puts $topo_file "geo $opts(number) $opts(seed)"
-		set str [$self rand-line $opts(nodes) $opts(scale) \
-		  $opts(method) $opts(connection_prob) $opts(beta) \
-		  $opts(gamma)]
-		puts $topo_file $str
-	  }
-	  "transit_stub" {
-		# filename
-                set i 0
-                while { 1 } {
-                        # avoid clashing with prev files, incr i
-	set topo_filename ts-$opts(transit_domains)-$opts(transit_nodes)-$i
-                        if ![file exists $topo_filename] {
-                                break
-                        }
-                        incr i   
-                }
-                set topo_file [open $topo_filename w]  
-              
-		# debugging stuff !!!
-		puts "stubs per transit $opts(stubs_per_transit), \
-		 ts extra $opts(ts_extra_edges), ss extra $opts(ss_extra_edges)"
-		puts "transit domains $opts(transit_domains), \
-		 domains_scale $opts(domains_scale), domains_method \
-		 $opts(domains_method)"
-		puts "domains_conn $opts(domains_connection_prob), \
-			beta $opts(domains_beta), gamma $opts(domains_gamma)"
-		puts "transit_nodes $opts(transit_nodes), \
-		  transit_scale $opts(transit_scale), \
-		  transit_method $opts(transit_method)"
-		puts "transit prob $opts(transit_connection_prob) \
-		  transit_beta $opts(transit_beta), \
-		  transit_gamma $opts(transit_gamma)"
-		puts "stub_nodes $opts(stub_nodes), \
-		  stub_method $opts(stub_method), \
-		  stub_conn $opts(stub_connection_prob) \
-		  stub_beta $opts(stub_beta) \
-		  stub_gamma $opts(stub_gamma)"
-
-		set total_nodes [expr $opts(transit_domains) * \
-		  $opts(transit_nodes) * [expr 1 + $opts(stubs_per_transit) \
-		  * $opts(stub_nodes)]]
-		puts "Total nodes = $total_nodes\n"
+		puts "nodes $opts(nodes), scale $opts(scale), \
+		     method $opts(method)"
+		puts "conn prob $opts(connection_prob), beta \
+		     $opts(beta), gamma $opts(gamma)"
+
+                puts $topo_file "geo $opts(number) $opts(seed)"
+		set str [$self rand-line $opts(nodes) $opts(scale) \
+		  $opts(method) $opts(connection_prob) $opts(beta) \
+		  $opts(gamma)]
+		puts $topo_file $str
+	  }
+	  "transit_stub" {
+		# filename
+                set i 0
+                while { 1 } {
+                        # avoid clashing with prev files, incr i
+	set topo_filename ts-$opts(transit_domains)-$opts(transit_nodes)-$i
+                        if ![file exists $topo_filename] {
+                                break
+                        }
+                        incr i   
+                }
+                set topo_file [open $topo_filename w]  
+              
+		# debugging stuff !!!
+		puts "stubs per transit $opts(stubs_per_transit), \
+		 ts extra $opts(ts_extra_edges), ss extra $opts(ss_extra_edges)"
+		puts "transit domains $opts(transit_domains), \
+		 domains_scale $opts(domains_scale), domains_method \
+		 $opts(domains_method)"
+		puts "domains_conn $opts(domains_connection_prob), \
+			beta $opts(domains_beta), gamma $opts(domains_gamma)"
+		puts "transit_nodes $opts(transit_nodes), \
+		  transit_scale $opts(transit_scale), \
+		  transit_method $opts(transit_method)"
+		puts "transit prob $opts(transit_connection_prob) \
+		  transit_beta $opts(transit_beta), \
+		  transit_gamma $opts(transit_gamma)"
+		puts "stub_nodes $opts(stub_nodes), \
+		  stub_method $opts(stub_method), \
+		  stub_conn $opts(stub_connection_prob) \
+		  stub_beta $opts(stub_beta) \
+		  stub_gamma $opts(stub_gamma)"
+
+		set total_nodes [expr $opts(transit_domains) * \
+		  $opts(transit_nodes) * [expr 1 + $opts(stubs_per_transit) \
+		  * $opts(stub_nodes)]]
+		puts "Total nodes = $total_nodes\n"
 
 		#check if number of nodes specified is diff from
 		# the total nodes after computation.
@@ -460,92 +460,92 @@
 			exit 1
 			
 		}	
-		$self setNodes all $total_nodes
-
-		puts $topo_file "ts $opts(number) $opts(seed)"
-		puts $topo_file "$opts(stubs_per_transit) \
-			$opts(ts_extra_edges) $opts(ss_extra_edges)"
-		set str [$self rand-line $opts(transit_domains) \
-		  $opts(domains_scale) $opts(domains_method) \
-		  $opts(domains_connection_prob) $opts(domains_beta) \
-		  $opts(domains_gamma)]
-		puts $topo_file $str
-		set str [$self rand-line $opts(transit_nodes) \
-		  $opts(transit_scale) $opts(transit_method) \
-		  $opts(transit_connection_prob) $opts(transit_beta) \
-		  $opts(transit_gamma)]
-		puts $topo_file $str
-		set str [$self rand-line $opts(stub_nodes) \
-		  $opts(stub_scale) $opts(stub_method) \
-		  $opts(stub_connection_prob) $opts(stub_beta) \
-		  $opts(stub_gamma)]
-		puts $topo_file $str
-	  }
-	  default { 
-	   puts "invalid type \"$opts(type)\"!! use \"topology -h\" for help"
-	   return
-	  }
-	}
-	flush $topo_file
-	close $topo_file
-        $self generate-topo-gatech $topo_filename
-	# cleanup if you want.. uncomment the next line !
-	# exec rm $topo_filename
-	# call the converter 'number' times
-	# no need for this loop if number is always 1 .. XXX
-	for { set i 0 } { $i < $opts(number) } { incr i } {
-        	# output file is appended by -i.gb 
+		$self setNodes all $total_nodes
+
+		puts $topo_file "ts $opts(number) $opts(seed)"
+		puts $topo_file "$opts(stubs_per_transit) \
+			$opts(ts_extra_edges) $opts(ss_extra_edges)"
+		set str [$self rand-line $opts(transit_domains) \
+		  $opts(domains_scale) $opts(domains_method) \
+		  $opts(domains_connection_prob) $opts(domains_beta) \
+		  $opts(domains_gamma)]
+		puts $topo_file $str
+		set str [$self rand-line $opts(transit_nodes) \
+		  $opts(transit_scale) $opts(transit_method) \
+		  $opts(transit_connection_prob) $opts(transit_beta) \
+		  $opts(transit_gamma)]
+		puts $topo_file $str
+		set str [$self rand-line $opts(stub_nodes) \
+		  $opts(stub_scale) $opts(stub_method) \
+		  $opts(stub_connection_prob) $opts(stub_beta) \
+		  $opts(stub_gamma)]
+		puts $topo_file $str
+	  }
+	  default { 
+	   puts "invalid type \"$opts(type)\"!! use \"topology -h\" for help"
+	   return
+	  }
+	}
+	flush $topo_file
+	close $topo_file
+        $self generate-topo-gatech $topo_filename
+	# cleanup if you want.. uncomment the next line !
+	# exec rm $topo_filename
+	# call the converter 'number' times
+	# no need for this loop if number is always 1 .. XXX
+	for { set i 0 } { $i < $opts(number) } { incr i } {
+        	# output file is appended by -i.gb 
         	$self convert-to-ns $topo_filename-$i.gb $opts(outfile) $opts(type)
 
-	}
-	# clean up... not sure if the file is needed by hierarchical addressing
-	# exec rm $topo_filename-0.gb
-
-}
-
-TG/itm instproc rand-line { nodes scale method conn_prob beta gamma } {
-	lappend str $nodes $scale
-	switch $method {
-                "waxman1" {
-                  # need alpha and beta
-                  lappend str 1 $conn_prob $beta
-                }
-                "waxman2" {
-                  lappend str 2 $conn_prob $beta
-                }
-                "pure-random" {
-                  # needs only alpha
-                  lappend str 3 $conn_prob
-                }
-                "doar-leslie" {
-                  # alpha, beta and gamma... X seems to use only alpha !
-                  lappend str 4 $conn_prob $beta $gamma
-                } 
-                "exponential" {
-                   # alpha .. XXX doesn't work now !!
-                  lappend str 5 $conn_prob
-		}
-                "locality" {
-		   # alpha , beta and gamma
-		   lappend str 6 $conn_prob $beta $gamma
-		}
-                default {
-                        puts "unidentified method $method .. aborting !!"
-			usage
-                        return
-                }
-	}
-	# puts "str $str"
-	return $str
-}
-
+	}
+	# clean up... not sure if the file is needed by hierarchical addressing
+	# exec rm $topo_filename-0.gb
+
+}
+
+TG/itm instproc rand-line { nodes scale method conn_prob beta gamma } {
+	lappend str $nodes $scale
+	switch $method {
+                "waxman1" {
+                  # need alpha and beta
+                  lappend str 1 $conn_prob $beta
+                }
+                "waxman2" {
+                  lappend str 2 $conn_prob $beta
+                }
+                "pure-random" {
+                  # needs only alpha
+                  lappend str 3 $conn_prob
+                }
+                "doar-leslie" {
+                  # alpha, beta and gamma... X seems to use only alpha !
+                  lappend str 4 $conn_prob $beta $gamma
+                } 
+                "exponential" {
+                   # alpha .. XXX doesn't work now !!
+                  lappend str 5 $conn_prob
+		}
+                "locality" {
+		   # alpha , beta and gamma
+		   lappend str 6 $conn_prob $beta $gamma
+		}
+                default {
+                        puts "unidentified method $method .. aborting !!"
+			usage
+                        return
+                }
+	}
+	# puts "str $str"
+	return $str
+}
+
 TG/itm instproc generate-topo-gatech { fn } {
         exec itm $fn
 }
-                   
-TG/itm instproc convert-to-ns { fn outfile type} {
+                   
+TG/itm instproc convert-to-ns { fn outfile type} {
 	
-	# to avoid generating false errors if sgb2ns is careless
+	# to avoid generating false errors if sgb2ns is careless
 	# about its return/exit value
 	#
 	# topofile generated by sgb2hierns program; has topology info used by
@@ -603,59 +603,59 @@
 
 
 
-proc comment { } {
-puts {
- * itm.c -- Driver to create graphs using geo(), geo_hier(), and transtub().
- *
- * Each argument is a file containing ONE set of specs for graph generation.
- * Such a file has the following format:
- *    <method keyword> <number of graphs> [<initial seed>]
- *    <method-dependent parameter lines>
- * Supported method names are "geo", "hier", and "ts".
- * Method-dependent parameter lines are described by the following:
- *    <geo_parms> ::=
- *        <n> <scale> <edgeprobmethod> <alpha> [<beta>] [<gamma>]
- *    <"geo" parms> ::= <geo_parms>
- *    <"hier" parms> ::=
- *          <number of levels> <edgeconnmethod> <threshold>
- *          <geo_parms>+  {one per number of levels}
- *    <"ts" parms> ::=
- *          <# stubs/trans node> <#t-s edges> <#s-s edges>
- *          <geo_parms>       {top-level parameters}
- *          <geo_parms>       {transit domain parameters}
- *          <geo_parms>       {stub domain parameters}
- *
- * Note that the stub domain "scale" parameter is ignored; a fraction
- * of the transit scale range is used.  This fraction is STUB_OFF_FACTOR,
- * defined in ts.c.
- *
- * From the foregoing, it follows that best results will be obtained with
- *   -- a SMALL value for top-level scale parameter
- *   -- a LARGE value for transit-level scale parameter
- * and then the value of stub-level scale parameter won't matter.
- *
- * The indicated number of graphs is produced using the given parameters.
- * If the initial seed is present, it is used; otherwise, DFLTSEED is used.
- *
- * OUTPUT FILE NAMING CONVENTION:
- * The i'th graph created with the parameters from file "arg" is placed
- * in file "arg-i.gb", where the first value of i is zero.
- }
-}
-
-###############################################################
-### the scenario generator keeps track of topology generator ##
-### and can be queried to get this info			     ##
-###############################################################
+proc comment { } {
+puts {
+ * itm.c -- Driver to create graphs using geo(), geo_hier(), and transtub().
+ *
+ * Each argument is a file containing ONE set of specs for graph generation.
+ * Such a file has the following format:
+ *    <method keyword> <number of graphs> [<initial seed>]
+ *    <method-dependent parameter lines>
+ * Supported method names are "geo", "hier", and "ts".
+ * Method-dependent parameter lines are described by the following:
+ *    <geo_parms> ::=
+ *        <n> <scale> <edgeprobmethod> <alpha> [<beta>] [<gamma>]
+ *    <"geo" parms> ::= <geo_parms>
+ *    <"hier" parms> ::=
+ *          <number of levels> <edgeconnmethod> <threshold>
+ *          <geo_parms>+  {one per number of levels}
+ *    <"ts" parms> ::=
+ *          <# stubs/trans node> <#t-s edges> <#s-s edges>
+ *          <geo_parms>       {top-level parameters}
+ *          <geo_parms>       {transit domain parameters}
+ *          <geo_parms>       {stub domain parameters}
+ *
+ * Note that the stub domain "scale" parameter is ignored; a fraction
+ * of the transit scale range is used.  This fraction is STUB_OFF_FACTOR,
+ * defined in ts.c.
+ *
+ * From the foregoing, it follows that best results will be obtained with
+ *   -- a SMALL value for top-level scale parameter
+ *   -- a LARGE value for transit-level scale parameter
+ * and then the value of stub-level scale parameter won't matter.
+ *
+ * The indicated number of graphs is produced using the given parameters.
+ * If the initial seed is present, it is used; otherwise, DFLTSEED is used.
+ *
+ * OUTPUT FILE NAMING CONVENTION:
+ * The i'th graph created with the parameters from file "arg" is placed
+ * in file "arg-i.gb", where the first value of i is zero.
+ }
+}
+
+###############################################################
+### the scenario generator keeps track of topology generator ##
+### and can be queried to get this info			     ##
+###############################################################
 
 Class ScenGen
-
-ScenGen set TG ""
-
-ScenGen proc setTG { tg } {
-	ScenGen set TG $tg
-}
-
-ScenGen proc getTG { } {
-	return [ScenGen set TG]
-}
+
+ScenGen set TG ""
+
+ScenGen proc setTG { tg } {
+	ScenGen set TG $tg
+}
+
+ScenGen proc getTG { } {
+	return [ScenGen set TG]
+}
--- tcl/lib/ns-agent.tcl	2001-08-17 15:00:42.000000000 -0400
+++ tcl/lib/ns-agent.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-agent.tcl,v 1.24 2001/08/17 19:00:42 kfall Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/lib/ns-agent.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 
 #
--- tcl/lib/ns-default.tcl	2006-10-23 01:33:16.000000000 -0400
+++ tcl/lib/ns-default.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -22,7 +22,7 @@
 #    specific prior written permission.
 # 
 
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-default.tcl,v 1.369 2006/10/23 05:33:16 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/lib/ns-default.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 
 # THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 # ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
--- tcl/lib/ns-lib.tcl	2007-01-30 00:00:51.000000000 -0500
+++ tcl/lib/ns-lib.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -32,7 +32,7 @@
 # SUCH DAMAGE.
 #
 
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-lib.tcl,v 1.274 2007/01/30 05:00:51 tom_henderson Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/lib/ns-lib.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 
 
 #
@@ -649,6 +653,9 @@
 	    ManualRtg {
 		    set ragent [$self create-manual-rtg-agent $node]
 	    }
+	    NOAH {
+		    set ragent [$self create-noah-agent $node]
+	    }
 	    default {
 		    eval $node addr $args
 		    puts "Wrong node routing agent!"
--- tcl/lib/ns-link.tcl	2004-10-28 19:35:39.000000000 -0400
+++ tcl/lib/ns-link.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-link.tcl,v 1.48 2004/10/28 23:35:39 haldar Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/lib/ns-link.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 
 Class Link
--- tcl/lib/ns-mobilenode.tcl	2007-01-30 00:00:51.000000000 -0500
+++ tcl/lib/ns-mobilenode.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-mobilenode.tcl,v 1.56 2007/01/30 05:00:51 tom_henderson Exp $
+# $Header: /home/rouil/cvsroot/ns-2.34/tcl/lib/ns-mobilenode.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 # Ported from CMU-Monarch project's mobility extensions -Padma, 10/98.
 #
--- tcl/lib/ns-packet.tcl	2005-06-17 13:41:16.000000000 -0400
+++ tcl/lib/ns-packet.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -33,7 +33,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-packet.tcl,v 1.55 2005/06/17 17:41:16 sfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/lib/ns-packet.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 # set up the packet format for the simulation
 # (initial version)
--- tcl/pgm/ns-pgm.tcl	2002-08-07 00:04:56.000000000 -0400
+++ tcl/pgm/ns-pgm.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,225 +1,225 @@
-#
-# Copyright (c) 2001 University of Southern California.
-# All rights reserved.                                            
-#                                                                
-# Redistribution and use in source and binary forms are permitted
-# provided that the above copyright notice and this paragraph are
-# duplicated in all such forms and that any documentation, advertising
-# materials, and other materials related to such distribution and use
-# acknowledge that the software was developed by the University of
-# Southern California, Information Sciences Institute.  The name of the
-# University may not be used to endorse or promote products derived from
-# this software without specific prior written permission.
-# 
-# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
-# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-#
-##
-# Pragmatic General Multicast (PGM), Reliable Multicast
-#
-# ns-pgm.tcl
-#
-# Auxillary OTcl procedures required by the PGM implementation, these are
-# used to set up Agent/PGM on new nodes when PGM is activated.
-#
-# Code adapted from Christos Papadopoulos.
-#
-# Ryan S. Barnett, 2001
-#
-
-# These default values should stay here since the pgm module might be disabled when option --disable-stl is used during configuration.
-################################################################
-# PGM
-################################################################
-
-RtModule/PGM set node_  ""
-
-PGMErrorModel set rate_         0.0     ;# just to eliminate warnings
-PGMErrorModel set errPkt_       0
-PGMErrorModel set errByte_      0
-PGMErrorModel set errTime_      0.0
-PGMErrorModel set onlink_       0
-PGMErrorModel set delay_        0
-PGMErrorModel set delay_pkt_    0
-PGMErrorModel set enable_       0
-PGMErrorModel set ndrops_       0
-PGMErrorModel set bandwidth_    2Mb
-PGMErrorModel set markecn_      false
-PGMErrorModel set debug_        false
-
-# *** PGM AGENT ***
-Agent/PGM set pgm_enabled_ 1
-
-# Number of seconds to wait between retransmitting a NAK that is waiting
-# for a NCF packet.
-Agent/PGM set nak_retrans_ival_ 50ms
-
-# The length of time for which a network element will continue to repeat
-# NAKs while waiting for a corresponding NCF.  Once this time expires and
-# no NCF is received, then we remove the entire repair state.
-Agent/PGM set nak_rpt_ival_ 1000ms
-
-# The length of time for which a network element will wait for the
-# corresponding RDATA before removing the entire repair state.
-Agent/PGM set nak_rdata_ival_ 10000ms
-
-# Once a NAK has been confirmed, network elements must discard all
-# further NAKs for up to this length of time.  Should be a fraction
-# of nak_rdata_ival_.
-Agent/PGM set nak_elim_ival_ 5000ms
-
-Agent/PGM instproc done {} { }
-
-# *** PGM SENDER ***
-
-# The length of time between sending SPM packets.
-Agent/PGM/Sender set spm_interval_ 500ms
-
-# Time to delay sending out an RDATA in response to a NAK packet, this
-# is to allow slow NAKs to get processed at one time, so we don't send
-# out duplicate RDATA.
-Agent/PGM/Sender set rdata_delay_ 70ms
-
-Agent/PGM/Sender instproc done {} { }
-
-# *** PGM RECEIVER ***
-
-# Maximum number of times we can send out a NAK and time-out waiting for
-# an NCF reply. Once we hit this many times, we discard the NAK state
-# entirely and loose data.
-Agent/PGM/Receiver set max_nak_ncf_retries_ 5
-
-# Maximum number of times we can time-out waiting for RDATA after an
-# NCF confirmation for a NAK request.  Once we hit this many times, we
-# discard the NAK state entirely and loose data.
-Agent/PGM/Receiver set max_nak_data_retries_ 5
-
-# A random amount of this time period (range) that will be selected to wait
-# for an NCF after detecting a gap in the data stream, before sending out
-# a NAK.
-Agent/PGM/Receiver set nak_bo_ivl_ 30ms
-
-# The amount of time to wait for a NCF packet after sending out a NAK
-# packet to the upstream node. If no NCF is received, another random
-# backoff time is observed, and then the NAK is retransmitted.
-Agent/PGM/Receiver set nak_rpt_ivl_ 50ms
-
-# The amount of time to wait for RDATA after receiving an NCF confirmation
-# for a given NAK. Once this timer expires, another random backoff time
-# is observed, and then the NAK is retransmitted.
-Agent/PGM/Receiver set nak_rdata_ivl_ 1000ms
-
-Agent/PGM/Receiver instproc done {} { }
-
-
-#
-# Register this PGM agent with a node.
-# Create and attach an PGM classifier to node.
-# Redirect node input to PGM classifier and
-# classifier output to either PGM agent or node
-#
-
-#Class RtModule/PGM -superclass RtModule
-
-RtModule/PGM instproc register { node } {
-	$self instvar node_ pgm_classifier_
-
-	set node_ $node
-	set pgm_classifier_ [new Classifier/Pgm]
-	set pgm_agent [new Agent/PGM]
-	$node attach $pgm_agent
-        $node set-pgm $pgm_agent
-	$node insert-entry $self $pgm_classifier_ 0
-	$pgm_classifier_ install 1 $pgm_agent
-}
-
-RtModule/PGM instproc get-outlink { iface } {
-	$self instvar node_
-
-	set oif [$node_ iif2oif $iface]
-	#set outlink [$node_ oif2link $oif]
-	return $oif    
-}
-
-Node instproc ifaceGetOutLink { iface } {
-	$self instvar ns_
-	set link [$self iif2link $iface]
-	set outlink [$ns_ link $self [$link src]]
-	set head [$outlink set head_]
-	return $head
-}
-
-#Node instproc ifaceGetOutLink { iface } {
-#        $self instvar ns_ id_ neighbor_
-#        foreach node $neighbor_ {
-#                set link [$ns_ set link_([$node id]:$id_)]
-#            if {[[$link set ifaceout_] id] == $iface} {
-#                set olink [$ns_ set link_($id_:[$node id])]
-#                set head [$olink set head_]
-#                return $head
-#            }
-#        }
-#        return -1
-#}
-
-Node instproc set-switch agent {
-	$self instvar switch_
-	set switch_ $agent
-}
-
-Node instproc agent port {
-        $self instvar agents_
-        foreach a $agents_ {
-		#puts "the agent at node [$self id] is $a"
-                if { [$a set agent_port_] == $port } {
-			#puts "node: [$self id], port:$port, agent:$a"
-                        return $a
-                }
-        }
-        return ""
-}
-
-# Set the Agent/PGM for a particular node.
-Node instproc set-pgm agent {
-    $self instvar pgm_agent_
-    set pgm_agent_ $agent
-}
-
-# Retrieve the Agent/PGM from a particular node.
-Node instproc get-pgm {} {
-    $self instvar pgm_agent_
-    return $pgm_agent_
-}
-
-# Agent/LMS/Receiver instproc log-loss {} {
-# }
-
-#
-# detach a lossobj from link(from:to)
-#
-Simulator instproc detach-lossmodel {lossobj from to} {
-	set link [$self link $from $to]
-	set head [$link head]
-	$head target [$lossobj target]
-}
-
-Agent/PGM/Sender instproc init {} {
-    eval $self next
-    set ns [Simulator instance]
-    $ns create-eventtrace Event $self
-}
-
-Agent/PGM/Receiver instproc init {} {
-    eval $self next
-    set ns [Simulator instance]
-    $ns create-eventtrace Event $self
-}
-
-Agent/PGM instproc init {} {
-    eval $self next
-    set ns [Simulator instance]
-    $ns create-eventtrace Event $self
-}
-
- 
+#
+# Copyright (c) 2001 University of Southern California.
+# All rights reserved.                                            
+#                                                                
+# Redistribution and use in source and binary forms are permitted
+# provided that the above copyright notice and this paragraph are
+# duplicated in all such forms and that any documentation, advertising
+# materials, and other materials related to such distribution and use
+# acknowledge that the software was developed by the University of
+# Southern California, Information Sciences Institute.  The name of the
+# University may not be used to endorse or promote products derived from
+# this software without specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
+# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+##
+# Pragmatic General Multicast (PGM), Reliable Multicast
+#
+# ns-pgm.tcl
+#
+# Auxillary OTcl procedures required by the PGM implementation, these are
+# used to set up Agent/PGM on new nodes when PGM is activated.
+#
+# Code adapted from Christos Papadopoulos.
+#
+# Ryan S. Barnett, 2001
+#
+
+# These default values should stay here since the pgm module might be disabled when option --disable-stl is used during configuration.
+################################################################
+# PGM
+################################################################
+
+RtModule/PGM set node_  ""
+
+PGMErrorModel set rate_         0.0     ;# just to eliminate warnings
+PGMErrorModel set errPkt_       0
+PGMErrorModel set errByte_      0
+PGMErrorModel set errTime_      0.0
+PGMErrorModel set onlink_       0
+PGMErrorModel set delay_        0
+PGMErrorModel set delay_pkt_    0
+PGMErrorModel set enable_       0
+PGMErrorModel set ndrops_       0
+PGMErrorModel set bandwidth_    2Mb
+PGMErrorModel set markecn_      false
+PGMErrorModel set debug_        false
+
+# *** PGM AGENT ***
+Agent/PGM set pgm_enabled_ 1
+
+# Number of seconds to wait between retransmitting a NAK that is waiting
+# for a NCF packet.
+Agent/PGM set nak_retrans_ival_ 50ms
+
+# The length of time for which a network element will continue to repeat
+# NAKs while waiting for a corresponding NCF.  Once this time expires and
+# no NCF is received, then we remove the entire repair state.
+Agent/PGM set nak_rpt_ival_ 1000ms
+
+# The length of time for which a network element will wait for the
+# corresponding RDATA before removing the entire repair state.
+Agent/PGM set nak_rdata_ival_ 10000ms
+
+# Once a NAK has been confirmed, network elements must discard all
+# further NAKs for up to this length of time.  Should be a fraction
+# of nak_rdata_ival_.
+Agent/PGM set nak_elim_ival_ 5000ms
+
+Agent/PGM instproc done {} { }
+
+# *** PGM SENDER ***
+
+# The length of time between sending SPM packets.
+Agent/PGM/Sender set spm_interval_ 500ms
+
+# Time to delay sending out an RDATA in response to a NAK packet, this
+# is to allow slow NAKs to get processed at one time, so we don't send
+# out duplicate RDATA.
+Agent/PGM/Sender set rdata_delay_ 70ms
+
+Agent/PGM/Sender instproc done {} { }
+
+# *** PGM RECEIVER ***
+
+# Maximum number of times we can send out a NAK and time-out waiting for
+# an NCF reply. Once we hit this many times, we discard the NAK state
+# entirely and loose data.
+Agent/PGM/Receiver set max_nak_ncf_retries_ 5
+
+# Maximum number of times we can time-out waiting for RDATA after an
+# NCF confirmation for a NAK request.  Once we hit this many times, we
+# discard the NAK state entirely and loose data.
+Agent/PGM/Receiver set max_nak_data_retries_ 5
+
+# A random amount of this time period (range) that will be selected to wait
+# for an NCF after detecting a gap in the data stream, before sending out
+# a NAK.
+Agent/PGM/Receiver set nak_bo_ivl_ 30ms
+
+# The amount of time to wait for a NCF packet after sending out a NAK
+# packet to the upstream node. If no NCF is received, another random
+# backoff time is observed, and then the NAK is retransmitted.
+Agent/PGM/Receiver set nak_rpt_ivl_ 50ms
+
+# The amount of time to wait for RDATA after receiving an NCF confirmation
+# for a given NAK. Once this timer expires, another random backoff time
+# is observed, and then the NAK is retransmitted.
+Agent/PGM/Receiver set nak_rdata_ivl_ 1000ms
+
+Agent/PGM/Receiver instproc done {} { }
+
+
+#
+# Register this PGM agent with a node.
+# Create and attach an PGM classifier to node.
+# Redirect node input to PGM classifier and
+# classifier output to either PGM agent or node
+#
+
+#Class RtModule/PGM -superclass RtModule
+
+RtModule/PGM instproc register { node } {
+	$self instvar node_ pgm_classifier_
+
+	set node_ $node
+	set pgm_classifier_ [new Classifier/Pgm]
+	set pgm_agent [new Agent/PGM]
+	$node attach $pgm_agent
+        $node set-pgm $pgm_agent
+	$node insert-entry $self $pgm_classifier_ 0
+	$pgm_classifier_ install 1 $pgm_agent
+}
+
+RtModule/PGM instproc get-outlink { iface } {
+	$self instvar node_
+
+	set oif [$node_ iif2oif $iface]
+	#set outlink [$node_ oif2link $oif]
+	return $oif    
+}
+
+Node instproc ifaceGetOutLink { iface } {
+	$self instvar ns_
+	set link [$self iif2link $iface]
+	set outlink [$ns_ link $self [$link src]]
+	set head [$outlink set head_]
+	return $head
+}
+
+#Node instproc ifaceGetOutLink { iface } {
+#        $self instvar ns_ id_ neighbor_
+#        foreach node $neighbor_ {
+#                set link [$ns_ set link_([$node id]:$id_)]
+#            if {[[$link set ifaceout_] id] == $iface} {
+#                set olink [$ns_ set link_($id_:[$node id])]
+#                set head [$olink set head_]
+#                return $head
+#            }
+#        }
+#        return -1
+#}
+
+Node instproc set-switch agent {
+	$self instvar switch_
+	set switch_ $agent
+}
+
+Node instproc agent port {
+        $self instvar agents_
+        foreach a $agents_ {
+		#puts "the agent at node [$self id] is $a"
+                if { [$a set agent_port_] == $port } {
+			#puts "node: [$self id], port:$port, agent:$a"
+                        return $a
+                }
+        }
+        return ""
+}
+
+# Set the Agent/PGM for a particular node.
+Node instproc set-pgm agent {
+    $self instvar pgm_agent_
+    set pgm_agent_ $agent
+}
+
+# Retrieve the Agent/PGM from a particular node.
+Node instproc get-pgm {} {
+    $self instvar pgm_agent_
+    return $pgm_agent_
+}
+
+# Agent/LMS/Receiver instproc log-loss {} {
+# }
+
+#
+# detach a lossobj from link(from:to)
+#
+Simulator instproc detach-lossmodel {lossobj from to} {
+	set link [$self link $from $to]
+	set head [$link head]
+	$head target [$lossobj target]
+}
+
+Agent/PGM/Sender instproc init {} {
+    eval $self next
+    set ns [Simulator instance]
+    $ns create-eventtrace Event $self
+}
+
+Agent/PGM/Receiver instproc init {} {
+    eval $self next
+    set ns [Simulator instance]
+    $ns create-eventtrace Event $self
+}
+
+Agent/PGM instproc init {} {
+    eval $self next
+    set ns [Simulator instance]
+    $ns create-eventtrace Event $self
+}
+
+ 
--- tcl/test/test-all-template1	2006-10-23 01:23:26.000000000 -0400
+++ tcl/test/test-all-template1	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-all-template1,v 1.37 2006/10/23 05:23:26 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-all-template1,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # The initial version of this script was written and contributed 
 # by Matt Mathis (mathis@psc.edu).
--- tcl/test/test-all-template1.win	2000-10-02 23:43:56.000000000 -0400
+++ tcl/test/test-all-template1.win	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-all-template1.win,v 1.2 2000/10/03 03:43:56 xuanc Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-all-template1.win,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # The initial version of this script was written and contributed 
 # by Matt Mathis (mathis@psc.edu).
--- tcl/test/test-suite-ecn-ack.tcl	2006-07-23 16:46:02.000000000 -0400
+++ tcl/test/test-suite-ecn-ack.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-ecn-ack.tcl,v 1.26 2006/07/23 20:46:02 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-ecn-ack.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 # To run all tests: test-all-ecn-ack
 set dir [pwd]
--- tcl/test/test-suite-ecn-full.tcl	2006-01-24 18:00:06.000000000 -0500
+++ tcl/test/test-suite-ecn-full.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-ecn-full.tcl,v 1.21 2006/01/24 23:00:06 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-ecn-full.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 # To run all tests: test-all-ecn-full
 
--- tcl/test/test-suite-ecn.tcl	2006-01-25 17:02:05.000000000 -0500
+++ tcl/test/test-suite-ecn.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-ecn.tcl,v 1.45 2006/01/25 22:02:05 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-ecn.tcl,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # To run all tests: test-all-ecn
 
--- tcl/test/test-suite-energy.tcl	2006-01-30 16:27:52.000000000 -0500
+++ tcl/test/test-suite-energy.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -1,558 +1,558 @@
-# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
-Agent/TCP set tcpTick_ 0.1
-# The default for tcpTick_ is being changed to reflect a changing reality.
-Agent/TCP set rfc2988_ false
-# The default for rfc2988_ is being changed to true.
-# FOR UPDATING GLOBAL DEFAULTS:
+# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
+Agent/TCP set tcpTick_ 0.1
+# The default for tcpTick_ is being changed to reflect a changing reality.
+Agent/TCP set rfc2988_ false
+# The default for rfc2988_ is being changed to true.
+# FOR UPDATING GLOBAL DEFAULTS:
 Agent/TCP set precisionReduce_ false ;   # default changed on 2006/1/24.
 Agent/TCP set rtxcur_init_ 6.0 ;      # Default changed on 2006/01/21
 Agent/TCP set updated_rttvar_ false ;  # Variable added on 2006/1/21
-Agent/TCP set minrto_ 1
-# default changed on 10/14/2004.
-Agent/TCP set useHeaders_ false
-# The default is being changed to useHeaders_ true.
-Agent/TCP set windowInit_ 1
-# The default is being changed to 2.
-Agent/TCP set singledup_ 0
-# The default is being changed to 1
+Agent/TCP set minrto_ 1
+# default changed on 10/14/2004.
+Agent/TCP set useHeaders_ false
+# The default is being changed to useHeaders_ true.
+Agent/TCP set windowInit_ 1
+# The default is being changed to 2.
+Agent/TCP set singledup_ 0
+# The default is being changed to 1
 Mac/802_11 set bugFix_timer_ false;     # default changed 2006/1/30
-#
-# Copyright (c) 1998 University of Southern California.
-# All rights reserved.                                            
-#                                                                
-# Redistribution and use in source and binary forms are permitted
-# provided that the above copyright notice and this paragraph are
-# duplicated in all such forms and that any documentation, advertising
-# materials, and other materials related to such distribution and use
-# acknowledge that the software was developed by the University of
-# Southern California, Information Sciences Institute.  The name of the
-# University may not be used to endorse or promote products derived from
-# this software without specific prior written permission.
-# 
-# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
-# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-# 
-# $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-energy.tcl,v 1.15 2006/01/30 21:27:52 mweigle Exp $
-
-# To run all tests: test-all-energy
-# to run individual test:
-# ns test-suite-energy.tcl dsdv
-# ns test-suite-energy.tcl dsr
-# ns test-suite-energy.tcl aodv
-# ns test-suite-energy.tcl brdcast0
-# To view a list of available test to run with this script:
-# ns test-suite-energy.tcl
-
-
-# ======================================================================
-# Define options
-# ======================================================================
-global opt
-set opt(chan)		Channel/WirelessChannel
-set opt(prop)		Propagation/TwoRayGround
-set opt(netif)		Phy/WirelessPhy
-set opt(mac)		Mac/802_11
-set opt(ifq)		Queue/DropTail/PriQueue
-set opt(ll)		LL
-set opt(ant)            Antenna/OmniAntenna
-
-set opt(x)		670	;# X dimension of the topography
-set opt(y)		670		;# Y dimension of the topography
-set opt(cp)		"cbr.tcl"
-set opt(sc)		"mobility.tcl"
-
-set opt(ifqlen)		50		;# max packet in ifq
-set opt(nn)		5		;# number of nodes
-set opt(seed)		0.0
-set opt(stop)		500.0		;# simulation time
-set opt(stop-newf)      700.0	 ;# extended run time for new feature simulations	
-
-set opt(tr)		estudy.tr	;# trace file
-set opt(nam)		temp.rands
-set opt(lm)             "off"           ;# log movement
-set opt(energymodel)    EnergyModel     ;
-set opt(initialenergy)  0.455               ;# Initial energy in Joules
-
-# ======================================================================
-# needs to be fixed later
-set AgentTrace			ON
-set RouterTrace			ON
-set MacTrace			OFF
-
-LL set mindelay_		50us
-LL set delay_			25us
-LL set bandwidth_		0	;# not used
-
-Agent/Null set sport_		0
-Agent/Null set dport_		0
-
-Agent/CBR set sport_		0
-Agent/CBR set dport_		0
-
-Agent/TCPSink set sport_	0
-Agent/TCPSink set dport_	0
-
-Agent/TCP set sport_		0
-Agent/TCP set dport_		0
-Agent/TCP set packetSize_	1460
-
-Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
-
-# unity gain, omni-directional antennas
-# set up the antennas to be centered in the node and 1.5 meters above it
-Antenna/OmniAntenna set X_ 0
-Antenna/OmniAntenna set Y_ 0
-Antenna/OmniAntenna set Z_ 1.5
-Antenna/OmniAntenna set Gt_ 1.0
-Antenna/OmniAntenna set Gr_ 1.0
-
-# Initialize the SharedMedia interface with parameters to make
-# it work like the 914MHz Lucent WaveLAN DSSS radio interface
-Phy/WirelessPhy set CPThresh_ 10.0
-Phy/WirelessPhy set CSThresh_ 1.559e-11
-Phy/WirelessPhy set RXThresh_ 3.652e-10
-Phy/WirelessPhy set Rb_ 2*1e6
-Phy/WirelessPhy set Pt_ 0.2818
-Phy/WirelessPhy set freq_ 914e+6 
-Phy/WirelessPhy set L_ 1.0
-
-# ======================================================================
-
-proc usage {}  {
-        global argv0
-	puts stderr "usage: ns $argv0 <tests> "
-	puts "Valid <tests> : dsdv dsr aodv brdcast0"
-        exit 1
-}
-
-
-proc getopt {argc argv} {
-	global opt
-	lappend optlist cp nn seed sc stop tr x y
-
-	for {set i 0} {$i < $argc} {incr i} {
-		set arg [lindex $argv $i]
-		if {[string range $arg 0 0] != "-"} continue
-
-		set name [string range $arg 1 end]
-		set opt($name) [lindex $argv [expr $i+1]]
-	}
-}
-
-Class TestSuite
-Class Test/brdcast0 -superclass TestSuite
-# 2 nodes brdcast req/replies to one another
-#This is a test for setting newly added features RADIO SLEEP MODE, Transition Energy Consumption, detailed energy trace
-
-Class Test/dsdv -superclass TestSuite
-Class Test/dsr -superclass TestSuite
-Class Test/aodv -superclass TestSuite
-
-TestSuite instproc init {} {
-global opt
-$self instvar ns_ topo  
-
-set ns_	[new Simulator]
-set topo	[new Topography]
-set god_    [new God]
-
-set tracefd	[open $opt(tr) w]
-set namtrace    [open $opt(nam) w]
-
-$topo load_flatgrid $opt(x) $opt(y)
-
-$ns_ trace-all $tracefd
-$ns_ namtrace-all-wireless $namtrace $opt(x) $opt(y)
-
-create-god $opt(nn)
-
-}
-
-TestSuite instproc finish {} {
-        $self instvar ns_
-	global quiet
-        $ns_ flush-trace
-        if { !$quiet } {
-            puts "running nam..."
-            exec nam temp.rands &
-        }
-        exit 0
-}
-
-Test/brdcast0 instproc init {} {
-    global opt 
-#node_
-#    $self instvar ns_ topo
-#    set opt(chan)           Channel/WirelessChannel    ;# channel type
-#    set opt(prop)           Propagation/TwoRayGround   ;# radio-propagation model
-#    set opt(netif)          Phy/WirelessPhy            ;# network interface type
-    set opt(mac)            Mac/SMAC                   ;# MAC type
-    #set opt(mac)            Mac/802_11                 ;# MAC type
-#    set opt(ifq)            Queue/DropTail/PriQueue    ;# interface queue type
-    set opt(ll)             LL                         ;# link layer type
-#    set opt(ant)            Antenna/OmniAntenna        ;# antenna model
-#    set opt(ifqlen)         50                         ;# max packet in ifq
-    set opt(x)              800
-    set opt(y)              800
-    set opt(rp)             DumbAgent               ;# routing protocol
-    set opt(tr)             temp.rands
- #   set opt(stop)           5.0
- #   set opt(stop-sync)      100.0        ;# extended run time for sync simulations
-    set opt(stop)           700.0	 ;# extended run time for new feature simulations	
-    set opt(seed)           1
- #   set opt(iP)           1.0	;# IDLE Power
- #   set opt(sP)           1.0	;# SLEEP Power
- #   set opt(tP)           1.0	;# TRANS Power
- #   set opt(rP)           1.0	;# RECV Power
- #   set opt(transT)       0.5	;# TRANSITION Time
- #   set opt(transP)       0.5	;# TRANSITION Power
-    set opt(initialenergy)  1000     ;# Initial energy in Joules
- #   set opt(energymodel)    EnergyModel     ;
-    set testname_ brdcast0
-  	set opt(nn) 2
-  
-    create-god $opt(nn)
- #   $self next
-    
-    
-}
-
-Test/brdcast0 instproc run {} {
-   global opt
-   $self instvar ns_ topo
-#   $self instvar ns_
-     set ns_         [new Simulator]
-      puts "Seeding Random number generator with $opt(seed)\n"
-    ns-random $opt(seed)
-    
-    set tracefd_	[open $opt(tr) w]
-    $ns_ trace-all $tracefd_
-     set topo_	    [new Topography]
-    $topo_ load_flatgrid $opt(x) $opt(y)
-    
-      $ns_ node-config -adhocRouting DumbAgent \
-			 -llType $opt(ll) \
-			 -macType Mac/SMAC \
-			 -ifqType $opt(ifq) \
-			 -ifqLen $opt(ifqlen) \
-			 -antType $opt(ant) \
-			 -propType $opt(prop) \
-			 -phyType $opt(netif) \
-			 -channelType $opt(chan) \
-			 -topoInstance $topo_ \
-			 -agentTrace ON \
-			 -routerTrace ON \
-			 -macTrace ON \
-			 -energyModel $opt(energymodel) \
-			 -idlePower 1.0 \
-			 -rxPower 1.0 \
-			 -txPower 2.0 \
-          		 -sleepPower 0.001 \
-          		 -transitionPower 0.2 \
-          		 -transitionTime 0.005 \
-			 -initialEnergy $opt(initialenergy)
-
-	Mac/SMAC set syncFlag_ 1
-	Mac/SMAC set dutyCycle_ 10
-
-	$ns_ set WirelessNewTrace_ ON
-	for {set i 0} {$i < $opt(nn) } {incr i} {
-		set node_($i) [$ns_ node]	
-		$node_($i) random-motion 0		;# disable random motion
-	}
-
-	set udp_(0) [new Agent/UDP]
-    	$ns_ attach-agent $node_(0) $udp_(0)
-
-	set null_(0) [new Agent/Null]
-	$ns_ attach-agent $node_(1) $null_(0)
-
-	set cbr_(0) [new Application/Traffic/CBR]
-	$cbr_(0) set packetSize_ 512
-	$cbr_(0) set interval_ 10.0
-	$cbr_(0) set random_ 1
-	$cbr_(0) set maxpkts_ 50000
-	$cbr_(0) attach-agent $udp_(0)
-
-	$ns_ connect $udp_(0) $null_(0)
-
-
-
-	$ns_ at 1.00 "$cbr_(0) start"
-#    	$ns_ at 1.0 "$ping1 start-WL-brdcast"
-#
-# Tell all the nodes when the simulation ends
-#
-for {set i 0} {$i < $opt(nn) } {incr i} {
-    $ns_ at $opt(stop) "$node_($i) reset";
-}
-$ns_ at $opt(stop) "puts \"NS EXITING...!!!\" ; $ns_ halt"
-$ns_ run
-}
-
-
-
-Test/dsdv instproc init {} {
-   global opt
-   $self instvar ns_ topo
-   set opt(rp)             DSDV
-   $self next
-}
-Test/dsdv instproc run {} {
-   global opt
-   $self instvar ns_ topo
-
-        $ns_ node-config -adhocRouting $opt(rp) \
-			 -llType $opt(ll) \
-			 -macType $opt(mac) \
-			 -ifqType $opt(ifq) \
-			 -ifqLen $opt(ifqlen) \
-			 -antType $opt(ant) \
-			 -propType $opt(prop) \
-			 -phyType $opt(netif) \
-			 -channel [new $opt(chan)] \
-			 -topoInstance $topo \
-			 -energyModel $opt(energymodel) \
-			 -macTrace ON \
-			 -rxPower 0.3 \
-			 -txPower 0.6 \
-			 -initialEnergy $opt(initialenergy)
-			 
-	for {set i 0} {$i < $opt(nn) } {incr i} {
-		set node_($i) [$ns_ node]	
-		$node_($i) random-motion 0		;# disable random motion
-	}
-
-#
-# Source the Connection and Movement scripts
-#
-if { $opt(cp) == "" } {
-	puts "*** NOTE: no connection pattern specified."
-        set opt(cp) "none"
-} else {
-	puts "Loading connection pattern..."
-	source $opt(cp)
-}
-
-
-#
-# Tell all the nodes when the simulation ends
-#
-for {set i 0} {$i < $opt(nn) } {incr i} {
-    $ns_ at $opt(stop).000000001 "$node_($i) reset";
-}
-$ns_ at $opt(stop).00000001 "puts \"NS EXITING...\" ; $ns_ halt"
-
-
-if { $opt(sc) == "" } {
-	puts "*** NOTE: no scenario file specified."
-        set opt(sc) "none"
-} else {
-	puts "Loading scenario file..."
-	source $opt(sc)
-	puts "Load complete..."
-}
-
-# Define node initial position in nam
-
-for {set i 0} {$i < $opt(nn)} {incr i} {
-
-    # 20 defines the node size in nam, must adjust it according to your scenario
-    # The function must be called after mobility model is defined
-
-    $ns_ initial_node_pos $node_($i) 20
-}
-
-$ns_ run
-}
-
-
-
-Test/dsr instproc init {} {
-   global opt
-   $self instvar ns_ topo
-   set opt(rp)             DSR
-   set opt(ifq)            CMUPriQueue
-   $self next
-}
-Test/dsr instproc run {} {
-   global opt
-   $self instvar ns_ topo
-        $ns_ node-config -adhocRouting $opt(rp) \
-			 -llType $opt(ll) \
-			 -macType $opt(mac) \
-			 -ifqType $opt(ifq) \
-			 -ifqLen $opt(ifqlen) \
-			 -antType $opt(ant) \
-			 -propType $opt(prop) \
-			 -phyType $opt(netif) \
-			 -channel [new $opt(chan)] \
-			 -topoInstance $topo \
-			 -energyModel $opt(energymodel) \
-			 -macTrace ON \
-			 -rxPower 0.3 \
-			 -txPower 0.6 \
-			 -initialEnergy $opt(initialenergy)
-			 
-	for {set i 0} {$i < $opt(nn) } {incr i} {
-		set node_($i) [$ns_ node]	
-		$node_($i) random-motion 0		;# disable random motion
-	}
-
-#
-# Source the Connection and Movement scripts
-#
-if { $opt(cp) == "" } {
-	puts "*** NOTE: no connection pattern specified."
-        set opt(cp) "none"
-} else {
-	puts "Loading connection pattern..."
-	source $opt(cp)
-}
-
-
-#
-# Tell all the nodes when the simulation ends
-#
-for {set i 0} {$i < $opt(nn) } {incr i} {
-    $ns_ at $opt(stop).000000001 "$node_($i) reset";
-}
-$ns_ at $opt(stop).00000001 "puts \"NS EXITING...\" ; $ns_ halt"
-
-
-if { $opt(sc) == "" } {
-	puts "*** NOTE: no scenario file specified."
-        set opt(sc) "none"
-} else {
-	puts "Loading scenario file..."
-	source $opt(sc)
-	puts "Load complete..."
-}
-
-# Define node initial position in nam
-
-for {set i 0} {$i < $opt(nn)} {incr i} {
-
-    # 20 defines the node size in nam, must adjust it according to your scenario
-    # The function must be called after mobility model is defined
-
-    $ns_ initial_node_pos $node_($i) 20
-}
-
-$ns_ run
-}
-
-
-
-Test/aodv instproc init {} {
-   global opt
-   $self instvar ns_ topo
-   set opt(rp)             AODV
-   $self next
-}
-Test/aodv instproc run {} {
-   global opt
-   $self instvar ns_ topo
-        $ns_ node-config -adhocRouting $opt(rp) \
-			 -llType $opt(ll) \
-			 -macType $opt(mac) \
-			 -ifqType $opt(ifq) \
-			 -ifqLen $opt(ifqlen) \
-			 -antType $opt(ant) \
-			 -propType $opt(prop) \
-			 -phyType $opt(netif) \
-			 -channel [new $opt(chan)] \
-			 -topoInstance $topo \
-			 -energyModel $opt(energymodel) \
-			 -macTrace ON \
-			 -rxPower 0.3 \
-			 -txPower 0.6 \
-			 -initialEnergy $opt(initialenergy)
-			 
-	for {set i 0} {$i < $opt(nn) } {incr i} {
-		set node_($i) [$ns_ node]	
-		$node_($i) random-motion 0		;# disable random motion
-	}
-
-#
-# Source the Connection and Movement scripts
-#
-if { $opt(cp) == "" } {
-	puts "*** NOTE: no connection pattern specified."
-        set opt(cp) "none"
-} else {
-	puts "Loading connection pattern..."
-	source $opt(cp)
-}
-
-
-#
-# Tell all the nodes when the simulation ends
-#
-for {set i 0} {$i < $opt(nn) } {incr i} {
-    $ns_ at $opt(stop).000000001 "$node_($i) reset";
-}
-$ns_ at $opt(stop).00000001 "puts \"NS EXITING...\" ; $ns_ halt"
-
-
-if { $opt(sc) == "" } {
-	puts "*** NOTE: no scenario file specified."
-        set opt(sc) "none"
-} else {
-	puts "Loading scenario file..."
-	source $opt(sc)
-	puts "Load complete..."
-}
-
-# Define node initial position in nam
-
-for {set i 0} {$i < $opt(nn)} {incr i} {
-
-    # 20 defines the node size in nam, must adjust it according to your scenario
-    # The function must be called after mobility model is defined
-
-    $ns_ initial_node_pos $node_($i) 20
-}
-
-$ns_ run
-}
-
-
-
-
-proc runtest {arg} {
-        global quiet
-        set quiet 0
-
-	set b [llength $arg]
-	if {$b == 1} {
-	        set test $arg
-        } elseif {$b == 2} {
-	        set test [lindex $arg 0]
-            if {[lindex $arg 1] == "QUIET"} {
-	        set quiet 1
-            }
-        } else {
-	        usage
-        }
-	switch $test {
-	      brdcast0 -
-		dsdv -
-	       dsr -
-		aodv {
-                     set t [new Test/$test]
-                }
-                default {
-	             stderr "Unknown test $test"
-		     exit 1
-                }
-         }
-	 $t run
-}
-
-global argv arg0 
-runtest $argv
-
-
-
+#
+# Copyright (c) 1998 University of Southern California.
+# All rights reserved.                                            
+#                                                                
+# Redistribution and use in source and binary forms are permitted
+# provided that the above copyright notice and this paragraph are
+# duplicated in all such forms and that any documentation, advertising
+# materials, and other materials related to such distribution and use
+# acknowledge that the software was developed by the University of
+# Southern California, Information Sciences Institute.  The name of the
+# University may not be used to endorse or promote products derived from
+# this software without specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
+# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+# 
+# $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-energy.tcl,v 1.2 2008/08/28 15:21:43 wimax Exp $
+
+# To run all tests: test-all-energy
+# to run individual test:
+# ns test-suite-energy.tcl dsdv
+# ns test-suite-energy.tcl dsr
+# ns test-suite-energy.tcl aodv
+# ns test-suite-energy.tcl brdcast0
+# To view a list of available test to run with this script:
+# ns test-suite-energy.tcl
+
+
+# ======================================================================
+# Define options
+# ======================================================================
+global opt
+set opt(chan)		Channel/WirelessChannel
+set opt(prop)		Propagation/TwoRayGround
+set opt(netif)		Phy/WirelessPhy
+set opt(mac)		Mac/802_11
+set opt(ifq)		Queue/DropTail/PriQueue
+set opt(ll)		LL
+set opt(ant)            Antenna/OmniAntenna
+
+set opt(x)		670	;# X dimension of the topography
+set opt(y)		670		;# Y dimension of the topography
+set opt(cp)		"cbr.tcl"
+set opt(sc)		"mobility.tcl"
+
+set opt(ifqlen)		50		;# max packet in ifq
+set opt(nn)		5		;# number of nodes
+set opt(seed)		0.0
+set opt(stop)		500.0		;# simulation time
+set opt(stop-newf)      700.0	 ;# extended run time for new feature simulations	
+
+set opt(tr)		estudy.tr	;# trace file
+set opt(nam)		temp.rands
+set opt(lm)             "off"           ;# log movement
+set opt(energymodel)    EnergyModel     ;
+set opt(initialenergy)  0.455               ;# Initial energy in Joules
+
+# ======================================================================
+# needs to be fixed later
+set AgentTrace			ON
+set RouterTrace			ON
+set MacTrace			OFF
+
+LL set mindelay_		50us
+LL set delay_			25us
+LL set bandwidth_		0	;# not used
+
+Agent/Null set sport_		0
+Agent/Null set dport_		0
+
+Agent/CBR set sport_		0
+Agent/CBR set dport_		0
+
+Agent/TCPSink set sport_	0
+Agent/TCPSink set dport_	0
+
+Agent/TCP set sport_		0
+Agent/TCP set dport_		0
+Agent/TCP set packetSize_	1460
+
+Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+
+# unity gain, omni-directional antennas
+# set up the antennas to be centered in the node and 1.5 meters above it
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set Rb_ 2*1e6
+Phy/WirelessPhy set Pt_ 0.2818
+Phy/WirelessPhy set freq_ 914e+6 
+Phy/WirelessPhy set L_ 1.0
+
+# ======================================================================
+
+proc usage {}  {
+        global argv0
+	puts stderr "usage: ns $argv0 <tests> "
+	puts "Valid <tests> : dsdv dsr aodv brdcast0"
+        exit 1
+}
+
+
+proc getopt {argc argv} {
+	global opt
+	lappend optlist cp nn seed sc stop tr x y
+
+	for {set i 0} {$i < $argc} {incr i} {
+		set arg [lindex $argv $i]
+		if {[string range $arg 0 0] != "-"} continue
+
+		set name [string range $arg 1 end]
+		set opt($name) [lindex $argv [expr $i+1]]
+	}
+}
+
+Class TestSuite
+Class Test/brdcast0 -superclass TestSuite
+# 2 nodes brdcast req/replies to one another
+#This is a test for setting newly added features RADIO SLEEP MODE, Transition Energy Consumption, detailed energy trace
+
+Class Test/dsdv -superclass TestSuite
+Class Test/dsr -superclass TestSuite
+Class Test/aodv -superclass TestSuite
+
+TestSuite instproc init {} {
+global opt
+$self instvar ns_ topo  
+
+set ns_	[new Simulator]
+set topo	[new Topography]
+set god_    [new God]
+
+set tracefd	[open $opt(tr) w]
+set namtrace    [open $opt(nam) w]
+
+$topo load_flatgrid $opt(x) $opt(y)
+
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $opt(x) $opt(y)
+
+create-god $opt(nn)
+
+}
+
+TestSuite instproc finish {} {
+        $self instvar ns_
+	global quiet
+        $ns_ flush-trace
+        if { !$quiet } {
+            puts "running nam..."
+            exec nam temp.rands &
+        }
+        exit 0
+}
+
+Test/brdcast0 instproc init {} {
+    global opt 
+#node_
+#    $self instvar ns_ topo
+#    set opt(chan)           Channel/WirelessChannel    ;# channel type
+#    set opt(prop)           Propagation/TwoRayGround   ;# radio-propagation model
+#    set opt(netif)          Phy/WirelessPhy            ;# network interface type
+    set opt(mac)            Mac/SMAC                   ;# MAC type
+    #set opt(mac)            Mac/802_11                 ;# MAC type
+#    set opt(ifq)            Queue/DropTail/PriQueue    ;# interface queue type
+    set opt(ll)             LL                         ;# link layer type
+#    set opt(ant)            Antenna/OmniAntenna        ;# antenna model
+#    set opt(ifqlen)         50                         ;# max packet in ifq
+    set opt(x)              800
+    set opt(y)              800
+    set opt(rp)             DumbAgent               ;# routing protocol
+    set opt(tr)             temp.rands
+ #   set opt(stop)           5.0
+ #   set opt(stop-sync)      100.0        ;# extended run time for sync simulations
+    set opt(stop)           700.0	 ;# extended run time for new feature simulations	
+    set opt(seed)           1
+ #   set opt(iP)           1.0	;# IDLE Power
+ #   set opt(sP)           1.0	;# SLEEP Power
+ #   set opt(tP)           1.0	;# TRANS Power
+ #   set opt(rP)           1.0	;# RECV Power
+ #   set opt(transT)       0.5	;# TRANSITION Time
+ #   set opt(transP)       0.5	;# TRANSITION Power
+    set opt(initialenergy)  1000     ;# Initial energy in Joules
+ #   set opt(energymodel)    EnergyModel     ;
+    set testname_ brdcast0
+  	set opt(nn) 2
+  
+    create-god $opt(nn)
+ #   $self next
+    
+    
+}
+
+Test/brdcast0 instproc run {} {
+   global opt
+   $self instvar ns_ topo
+#   $self instvar ns_
+     set ns_         [new Simulator]
+      puts "Seeding Random number generator with $opt(seed)\n"
+    ns-random $opt(seed)
+    
+    set tracefd_	[open $opt(tr) w]
+    $ns_ trace-all $tracefd_
+     set topo_	    [new Topography]
+    $topo_ load_flatgrid $opt(x) $opt(y)
+    
+      $ns_ node-config -adhocRouting DumbAgent \
+			 -llType $opt(ll) \
+			 -macType Mac/SMAC \
+			 -ifqType $opt(ifq) \
+			 -ifqLen $opt(ifqlen) \
+			 -antType $opt(ant) \
+			 -propType $opt(prop) \
+			 -phyType $opt(netif) \
+			 -channelType $opt(chan) \
+			 -topoInstance $topo_ \
+			 -agentTrace ON \
+			 -routerTrace ON \
+			 -macTrace ON \
+			 -energyModel $opt(energymodel) \
+			 -idlePower 1.0 \
+			 -rxPower 1.0 \
+			 -txPower 2.0 \
+          		 -sleepPower 0.001 \
+          		 -transitionPower 0.2 \
+          		 -transitionTime 0.005 \
+			 -initialEnergy $opt(initialenergy)
+
+	Mac/SMAC set syncFlag_ 1
+	Mac/SMAC set dutyCycle_ 10
+
+	$ns_ set WirelessNewTrace_ ON
+	for {set i 0} {$i < $opt(nn) } {incr i} {
+		set node_($i) [$ns_ node]	
+		$node_($i) random-motion 0		;# disable random motion
+	}
+
+	set udp_(0) [new Agent/UDP]
+    	$ns_ attach-agent $node_(0) $udp_(0)
+
+	set null_(0) [new Agent/Null]
+	$ns_ attach-agent $node_(1) $null_(0)
+
+	set cbr_(0) [new Application/Traffic/CBR]
+	$cbr_(0) set packetSize_ 512
+	$cbr_(0) set interval_ 10.0
+	$cbr_(0) set random_ 1
+	$cbr_(0) set maxpkts_ 50000
+	$cbr_(0) attach-agent $udp_(0)
+
+	$ns_ connect $udp_(0) $null_(0)
+
+
+
+	$ns_ at 1.00 "$cbr_(0) start"
+#    	$ns_ at 1.0 "$ping1 start-WL-brdcast"
+#
+# Tell all the nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop) "$node_($i) reset";
+}
+$ns_ at $opt(stop) "puts \"NS EXITING...!!!\" ; $ns_ halt"
+$ns_ run
+}
+
+
+
+Test/dsdv instproc init {} {
+   global opt
+   $self instvar ns_ topo
+   set opt(rp)             DSDV
+   $self next
+}
+Test/dsdv instproc run {} {
+   global opt
+   $self instvar ns_ topo
+
+        $ns_ node-config -adhocRouting $opt(rp) \
+			 -llType $opt(ll) \
+			 -macType $opt(mac) \
+			 -ifqType $opt(ifq) \
+			 -ifqLen $opt(ifqlen) \
+			 -antType $opt(ant) \
+			 -propType $opt(prop) \
+			 -phyType $opt(netif) \
+			 -channel [new $opt(chan)] \
+			 -topoInstance $topo \
+			 -energyModel $opt(energymodel) \
+			 -macTrace ON \
+			 -rxPower 0.3 \
+			 -txPower 0.6 \
+			 -initialEnergy $opt(initialenergy)
+			 
+	for {set i 0} {$i < $opt(nn) } {incr i} {
+		set node_($i) [$ns_ node]	
+		$node_($i) random-motion 0		;# disable random motion
+	}
+
+#
+# Source the Connection and Movement scripts
+#
+if { $opt(cp) == "" } {
+	puts "*** NOTE: no connection pattern specified."
+        set opt(cp) "none"
+} else {
+	puts "Loading connection pattern..."
+	source $opt(cp)
+}
+
+
+#
+# Tell all the nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).000000001 "$node_($i) reset";
+}
+$ns_ at $opt(stop).00000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+
+if { $opt(sc) == "" } {
+	puts "*** NOTE: no scenario file specified."
+        set opt(sc) "none"
+} else {
+	puts "Loading scenario file..."
+	source $opt(sc)
+	puts "Load complete..."
+}
+
+# Define node initial position in nam
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+
+    # 20 defines the node size in nam, must adjust it according to your scenario
+    # The function must be called after mobility model is defined
+
+    $ns_ initial_node_pos $node_($i) 20
+}
+
+$ns_ run
+}
+
+
+
+Test/dsr instproc init {} {
+   global opt
+   $self instvar ns_ topo
+   set opt(rp)             DSR
+   set opt(ifq)            CMUPriQueue
+   $self next
+}
+Test/dsr instproc run {} {
+   global opt
+   $self instvar ns_ topo
+        $ns_ node-config -adhocRouting $opt(rp) \
+			 -llType $opt(ll) \
+			 -macType $opt(mac) \
+			 -ifqType $opt(ifq) \
+			 -ifqLen $opt(ifqlen) \
+			 -antType $opt(ant) \
+			 -propType $opt(prop) \
+			 -phyType $opt(netif) \
+			 -channel [new $opt(chan)] \
+			 -topoInstance $topo \
+			 -energyModel $opt(energymodel) \
+			 -macTrace ON \
+			 -rxPower 0.3 \
+			 -txPower 0.6 \
+			 -initialEnergy $opt(initialenergy)
+			 
+	for {set i 0} {$i < $opt(nn) } {incr i} {
+		set node_($i) [$ns_ node]	
+		$node_($i) random-motion 0		;# disable random motion
+	}
+
+#
+# Source the Connection and Movement scripts
+#
+if { $opt(cp) == "" } {
+	puts "*** NOTE: no connection pattern specified."
+        set opt(cp) "none"
+} else {
+	puts "Loading connection pattern..."
+	source $opt(cp)
+}
+
+
+#
+# Tell all the nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).000000001 "$node_($i) reset";
+}
+$ns_ at $opt(stop).00000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+
+if { $opt(sc) == "" } {
+	puts "*** NOTE: no scenario file specified."
+        set opt(sc) "none"
+} else {
+	puts "Loading scenario file..."
+	source $opt(sc)
+	puts "Load complete..."
+}
+
+# Define node initial position in nam
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+
+    # 20 defines the node size in nam, must adjust it according to your scenario
+    # The function must be called after mobility model is defined
+
+    $ns_ initial_node_pos $node_($i) 20
+}
+
+$ns_ run
+}
+
+
+
+Test/aodv instproc init {} {
+   global opt
+   $self instvar ns_ topo
+   set opt(rp)             AODV
+   $self next
+}
+Test/aodv instproc run {} {
+   global opt
+   $self instvar ns_ topo
+        $ns_ node-config -adhocRouting $opt(rp) \
+			 -llType $opt(ll) \
+			 -macType $opt(mac) \
+			 -ifqType $opt(ifq) \
+			 -ifqLen $opt(ifqlen) \
+			 -antType $opt(ant) \
+			 -propType $opt(prop) \
+			 -phyType $opt(netif) \
+			 -channel [new $opt(chan)] \
+			 -topoInstance $topo \
+			 -energyModel $opt(energymodel) \
+			 -macTrace ON \
+			 -rxPower 0.3 \
+			 -txPower 0.6 \
+			 -initialEnergy $opt(initialenergy)
+			 
+	for {set i 0} {$i < $opt(nn) } {incr i} {
+		set node_($i) [$ns_ node]	
+		$node_($i) random-motion 0		;# disable random motion
+	}
+
+#
+# Source the Connection and Movement scripts
+#
+if { $opt(cp) == "" } {
+	puts "*** NOTE: no connection pattern specified."
+        set opt(cp) "none"
+} else {
+	puts "Loading connection pattern..."
+	source $opt(cp)
+}
+
+
+#
+# Tell all the nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).000000001 "$node_($i) reset";
+}
+$ns_ at $opt(stop).00000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+
+if { $opt(sc) == "" } {
+	puts "*** NOTE: no scenario file specified."
+        set opt(sc) "none"
+} else {
+	puts "Loading scenario file..."
+	source $opt(sc)
+	puts "Load complete..."
+}
+
+# Define node initial position in nam
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+
+    # 20 defines the node size in nam, must adjust it according to your scenario
+    # The function must be called after mobility model is defined
+
+    $ns_ initial_node_pos $node_($i) 20
+}
+
+$ns_ run
+}
+
+
+
+
+proc runtest {arg} {
+        global quiet
+        set quiet 0
+
+	set b [llength $arg]
+	if {$b == 1} {
+	        set test $arg
+        } elseif {$b == 2} {
+	        set test [lindex $arg 0]
+            if {[lindex $arg 1] == "QUIET"} {
+	        set quiet 1
+            }
+        } else {
+	        usage
+        }
+	switch $test {
+	      brdcast0 -
+		dsdv -
+	       dsr -
+		aodv {
+                     set t [new Test/$test]
+                }
+                default {
+	             stderr "Unknown test $test"
+		     exit 1
+                }
+         }
+	 $t run
+}
+
+global argv arg0 
+runtest $argv
+
+
+
--- tcl/test/test-suite-friendly.tcl	2006-10-23 02:32:48.000000000 -0400
+++ tcl/test/test-suite-friendly.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-friendly.tcl,v 1.76 2006/10/23 06:32:48 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-friendly.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 
 source misc_simple.tcl
--- tcl/test/test-suite-oddBehaviors.tcl	2006-10-07 11:38:03.000000000 -0400
+++ tcl/test/test-suite-oddBehaviors.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-oddBehaviors.tcl,v 1.15 2006/10/07 15:38:03 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-oddBehaviors.tcl,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # To view a list of available tests to run with this script:
 # ns test-suite-tcpVariants.tcl
--- tcl/test/test-suite-red.tcl	2006-12-21 15:01:41.000000000 -0500
+++ tcl/test/test-suite-red.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-red.tcl,v 1.62 2006/12/21 20:01:41 tom_henderson Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-red.tcl,v 1.1.1.1 2008/04/11 18:40:21 rouil Exp $
 #
 # This test suite reproduces most of the tests from the following note:
 # Floyd, S., 
--- tcl/test/test-suite-tcp.tcl	2006-01-25 17:02:05.000000000 -0500
+++ tcl/test/test-suite-tcp.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-tcp.tcl,v 1.38 2006/01/25 22:02:05 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-tcp.tcl,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # To view a list of available tests to run with this script:
 # ns test-suite-tcp.tcl
--- tcl/test/test-suite-tcpVariants.tcl	2006-10-22 11:24:49.000000000 -0400
+++ tcl/test/test-suite-tcpVariants.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-tcpVariants.tcl,v 1.31 2006/10/22 15:24:49 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-tcpVariants.tcl,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # To view a list of available tests to run with this script:
 # ns test-suite-tcpVariants.tcl
--- tcl/test/test-suite-testReno.tcl	2006-01-24 18:00:08.000000000 -0500
+++ tcl/test/test-suite-testReno.tcl	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/test/test-suite-testReno.tcl,v 1.18 2006/01/24 23:00:08 sallyfloyd Exp $
+# @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcl/test/test-suite-testReno.tcl,v 1.1.1.1 2008/04/11 18:40:22 rouil Exp $
 #
 # To view a list of available tests to run with this script:
 # ns test-suite-testReno.tcl
--- tcp/tcp.cc	2007-01-12 13:08:52.000000000 -0500
+++ tcp/tcp.cc	2009-04-01 18:01:36.000000000 -0400
@@ -34,7 +34,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp.cc,v 1.173 2007/01/12 18:08:52 sallyfloyd Exp $ (LBL)";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/tcp/tcp.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)";
 #endif
 
 #include <stdlib.h>
--- tcp/tcp-full.cc	2006-06-30 19:18:01.000000000 -0400
+++ tcp/tcp-full.cc	2009-04-01 18:01:36.000000000 -0400
@@ -108,7 +108,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp-full.cc,v 1.123 2006/06/30 23:18:01 sallyfloyd Exp $ (LBL)";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/tcp/tcp-full.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)";
 #endif
 
 #include "ip.h"
--- tcp/tcp-full.h	2006-05-30 16:30:30.000000000 -0400
+++ tcp/tcp-full.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp-full.h,v 1.57 2006/05/30 20:30:30 pradkin Exp $ (LBL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcp/tcp-full.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
  */
 
 #ifndef ns_tcp_full_h
--- tcp/tcp.h	2006-06-13 21:12:28.000000000 -0400
+++ tcp/tcp.h	2009-04-01 18:01:36.000000000 -0400
@@ -30,7 +30,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp.h,v 1.126 2006/06/14 01:12:28 sallyfloyd Exp $ (LBL)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/tcp/tcp.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (LBL)
  */
 #ifndef ns_tcp_h
 #define ns_tcp_h
--- tools/ranvar.cc	2006-11-18 14:54:54.000000000 -0500
+++ tools/ranvar.cc	2009-04-01 18:01:36.000000000 -0400
@@ -2,46 +2,23 @@
 /*
  * Copyright (c) Xerox Corporation 1997. All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
+ * License is granted to copy, to use, and to make and to use derivative
+ * works for research and evaluation purposes, provided that Xerox is
+ * acknowledged in all documentation pertaining to any such copy or derivative
+ * work. Xerox grants no other licenses expressed or implied. The Xerox trade
+ * name should not be used in any advertising without its written permission.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- * Linking this file statically or dynamically with other modules is making
- * a combined work based on this file.  Thus, the terms and conditions of
- * the GNU General Public License cover the whole combination.
- *
- * In addition, as a special exception, the copyright holders of this file
- * give you permission to combine this file with free software programs or
- * libraries that are released under the GNU LGPL and with code included in
- * the standard release of ns-2 under the Apache 2.0 license or under
- * otherwise-compatible licenses with advertising requirements (or modified
- * versions of such code, with unchanged license).  You may copy and
- * distribute such a system following the terms of the GNU GPL for this
- * file and the licenses of the other code concerned, provided that you
- * include the source code of that other code when and as the GNU GPL
- * requires distribution of source code.
- *
- * Note that people who make modified versions of this file are not
- * obligated to grant this special exception for their modified versions;
- * it is their choice whether to do so.  The GNU General Public License
- * gives permission to release a modified version without this exception;
- * this exception also makes it possible to release a modified version
- * which carries forward this exception.
+ * XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
+ * MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE
+ * FOR ANY PARTICULAR PURPOSE.  The software is provided "as is" without
+ * express or implied warranty of any kind.
+ *  
+ * These notices must be retained in any copies of any part of this software.
  */
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /cvsroot/nsnam/ns-2/tools/ranvar.cc,v 1.21 2006/11/18 19:54:54 mweigle Exp $ (Xerox)";
+    "@(#) $Header: /home/rouil/cvsroot/ns-2.34/tools/ranvar.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (Xerox)";
 #endif
 
 #include <stdio.h>
--- tools/ranvar.h	2006-02-02 13:19:44.000000000 -0500
+++ tools/ranvar.h	2009-04-01 18:01:36.000000000 -0400
@@ -2,43 +2,20 @@
 /*
  * Copyright (c) Xerox Corporation 1997. All rights reserved.
  *  
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- * Linking this file statically or dynamically with other modules is making
- * a combined work based on this file.  Thus, the terms and conditions of
- * the GNU General Public License cover the whole combination.
- *
- * In addition, as a special exception, the copyright holders of this file
- * give you permission to combine this file with free software programs or
- * libraries that are released under the GNU LGPL and with code included in
- * the standard release of ns-2 under the Apache 2.0 license or under
- * otherwise-compatible licenses with advertising requirements (or modified
- * versions of such code, with unchanged license).  You may copy and
- * distribute such a system following the terms of the GNU GPL for this
- * file and the licenses of the other code concerned, provided that you
- * include the source code of that other code when and as the GNU GPL
- * requires distribution of source code.
- *
- * Note that people who make modified versions of this file are not
- * obligated to grant this special exception for their modified versions;
- * it is their choice whether to do so.  The GNU General Public License
- * gives permission to release a modified version without this exception;
- * this exception also makes it possible to release a modified version
- * which carries forward this exception.
+ * License is granted to copy, to use, and to make and to use derivative
+ * works for research and evaluation purposes, provided that Xerox is
+ * acknowledged in all documentation pertaining to any such copy or derivative
+ * work. Xerox grants no other licenses expressed or implied. The Xerox trade
+ * name should not be used in any advertising without its written permission.
+ *  
+ * XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
+ * MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE
+ * FOR ANY PARTICULAR PURPOSE.  The software is provided "as is" without
+ * express or implied warranty of any kind.
+ *  
+ * These notices must be retained in any copies of any part of this software.
  *
- * @(#) $Header: /cvsroot/nsnam/ns-2/tools/ranvar.h,v 1.17 2006/02/02 18:19:44 mweigle Exp $ (Xerox)
+ * @(#) $Header: /home/rouil/cvsroot/ns-2.34/tools/ranvar.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $ (Xerox)
  */
 
 #ifndef ns_ranvar_h
--- trace/cmu-trace.cc	2006-03-21 17:31:32.000000000 -0500
+++ trace/cmu-trace.cc	2009-04-01 18:01:36.000000000 -0400
@@ -34,7 +34,7 @@
  * Ported from CMU/Monarch's code, appropriate copyright applies.
  * nov'98 -Padma.
  *
- * $Header: /cvsroot/nsnam/ns-2/trace/cmu-trace.cc,v 1.89 2006/03/21 22:31:32 liyuan Exp $
+ * $Header: /home/rouil/cvsroot/ns-2.34/trace/cmu-trace.cc,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $
  */
 
 #include <packet.h>
--- trace/cmu-trace.h	2005-07-26 21:13:45.000000000 -0400
+++ trace/cmu-trace.h	2009-04-01 18:01:36.000000000 -0400
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Header: /cvsroot/nsnam/ns-2/trace/cmu-trace.h,v 1.25 2005/07/27 01:13:45 tomh Exp $
+ * $Header: /home/rouil/cvsroot/ns-2.34/trace/cmu-trace.h,v 1.1.1.1 2008/04/11 18:40:29 rouil Exp $
  */
 
 /* Ported from CMU/Monarch's code, nov'98 -Padma.*/
--- validate	2006-02-02 13:19:44.000000000 -0500
+++ validate	2009-04-01 18:01:36.000000000 -0400
@@ -19,7 +19,7 @@
 # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 #
-# $Header: /cvsroot/nsnam/ns-2/validate,v 1.145 2006/02/02 18:19:44 mweigle Exp $
+# $Header: /home/rouil/cvsroot/ns-2.34/validate,v 1.1.1.1 2008/04/11 18:40:19 rouil Exp $
 
 try () {
         for excluding in $cygwin_exclude; do
--- validate-full	2001-07-18 13:31:24.000000000 -0400
+++ validate-full	2009-04-01 18:01:35.000000000 -0400
@@ -19,7 +19,7 @@
 # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 #
-# $Header: /cvsroot/nsnam/ns-2/validate-full,v 1.1 2001/07/18 17:31:24 kfall Exp $
+# $Header: /home/rouil/cvsroot/ns-2.34/validate-full,v 1.1.1.1 2008/04/11 18:40:19 rouil Exp $
 
 try () {
 	echo "*** $1"
--- validate-wired	2003-02-02 17:16:13.000000000 -0500
+++ validate-wired	2009-04-01 18:01:36.000000000 -0400
@@ -19,7 +19,7 @@
 # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 #
-# $Header: /cvsroot/nsnam/ns-2/validate-wired,v 1.7 2003/02/02 22:16:13 xuanc Exp $
+# $Header: /home/rouil/cvsroot/ns-2.34/validate-wired,v 1.1.1.1 2008/04/11 18:40:19 rouil Exp $
 
 try () {
 	echo "*** $1"
--- validate-wireless	2000-10-09 18:46:35.000000000 -0400
+++ validate-wireless	2009-04-01 18:01:36.000000000 -0400
@@ -19,7 +19,7 @@
 # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 #
-# $Header: /cvsroot/nsnam/ns-2/validate-wireless,v 1.2 2000/10/09 22:46:35 yewei Exp $
+# $Header: /home/rouil/cvsroot/ns-2.34/validate-wireless,v 1.1.1.1 2008/04/11 18:40:19 rouil Exp $
 
 try () {
 	echo "*** $1"
